(window.webpackJsonp=window.webpackJsonp||[]).push([[384],{790:function(e,t,s){"use strict";s.r(t);var a=s(46),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"simple-summary"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[e._v("#")]),e._v(" Simple Summary")]),e._v(" "),s("p",[e._v("In the 21st century, on a blockchain circulating billions of ETH, formal specification and verification are an essential tool against loss. Yet the design of the EVM makes this unnecessarily difficult. Further, the design of the EVM makes near-linear-time compilation to machine code difficult. We propose to move forward with proposals to resolve these problems by tightening EVM security guarantees and reducing barriers to performance.")]),e._v(" "),s("h2",{attrs:{id:"abstract"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),s("p",[e._v("EVM code is currently difficult to statically analyze, hobbling critical tools for preventing the many expensive bugs our blockchain has experienced. Further, none of the current implementations of the Ethereum Virtual Machine—including the compilers—are sufficiently performant to reduce the need for precompiles and otherwise meet the network's long-term demands.  This proposal identifies dynamic jumps as a major reason for these issues, and proposes changes to the EVM specification to address the problem, making further efforts towards a safer and more performant the EVM possible.")]),e._v(" "),s("p",[e._v("We also propose to validate—in near-linear time—that EVM contracts correctly use subroutines, avoid misuse of the stack, and meet other safety conditions "),s("em",[e._v("before")]),e._v(" placing them on the blockchain.  Validated code precludes most runtime exceptions and the need to test for them.  And well-behaved control flow and use of the stack makes life easier for interpreters, compilers, formal analysis, and other tools.")]),e._v(" "),s("h2",{attrs:{id:"motivation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),s("p",[e._v("Currently the EVM supports only dynamic jumps, where the address to jump to is an argument on the stack.  Worse, the EVM fails to provide ordinary, alternative control flow facilities like subroutines and switches provided by Wasm and most CPUs.  So dynamic jumps cannot be avoided, yet they obscure the structure of the code and thus mostly inhibit control- and data-flow analysis.  This puts the quality and speed of optimized compilation fundamentally at odds.  Further, since many jumps can potentially be to any jump destination in the code, the number of possible paths through the code can go up as the product of the number of jumps by the number of destinations, as does the time complexity of static analysis.  Many of these cases are undecidable at deployment time, further inhibiting static and formal analyses.")]),e._v(" "),s("p",[e._v("However, given Ethereum's security requirements, "),s("strong",[e._v("near-linear")]),e._v(" "),s("strong",[s("code",[e._v("n log n")])]),e._v(" "),s("strong",[e._v("time complexity")]),e._v(" is essential.  Otherwise, Contracts can be crafted or discovered with quadratic complexity to use as denial of service attack vectors against validations and optimizations.")]),e._v(" "),s("p",[e._v("But absent dynamic jumps code can be statically analyzed in linear time.  That allows for "),s("em",[e._v("linear time validation")]),e._v(".  It also allows for code generation and such optimizations as can be done in "),s("code",[e._v("log n")]),e._v(" time to comprise an "),s("em",[s("code",[e._v("n log n")])]),e._v(" "),s("em",[e._v("time compiler")]),e._v(".")]),e._v(" "),s("p",[e._v("And absent dynamic jumps, and with proper subroutines the EVM is a better target for code generation from other languages, including")]),e._v(" "),s("ul",[s("li",[e._v("Solidity")]),e._v(" "),s("li",[e._v("Vyper")]),e._v(" "),s("li",[e._v("LLVM IR\n"),s("ul",[s("li",[e._v("front ends include C, C++, Common Lisp, D, Fortran, Haskell, Java, Javascript, Kotlin, Lua, Objective-C, Pony, Pure, Python, Ruby, Rust, Scala, Scheme, and Swift")])])])]),e._v(" "),s("p",[e._v("The result is that all of the following validations and optimizations can be done at deployment time with near-linear "),s("code",[e._v("(n log n)")]),e._v(" time complexity.")]),e._v(" "),s("ul",[s("li",[e._v("The absence of most exceptional halting states can be validated.")]),e._v(" "),s("li",[e._v("The maximum use of resources can be sometimes be calculated.")]),e._v(" "),s("li",[e._v("Bytecode can be compiled to machine code in near-linear time.")]),e._v(" "),s("li",[e._v("Compilation can more effectively optimize use of smaller registers.")]),e._v(" "),s("li",[e._v("Compilation can more effectively optimize injection of gas metering.")])]),e._v(" "),s("h2",{attrs:{id:"specification"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),s("h3",{attrs:{id:"dependencies"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dependencies"}},[e._v("#")]),e._v(" Dependencies")]),e._v(" "),s("blockquote",[s("p",[s("strong",[s("RouterLink",{attrs:{to:"/eip-1702.html"}},[e._v("EIP-1702")]),e._v(". Generalized Account Versioning Scheme.")],1),e._v(" This proposal needs a versioning scheme to allow for its bytecode (and eventually eWasm bytecode) to be deployed with existing bytecode on the same blockchain.")])]),e._v(" "),s("h3",{attrs:{id:"proposal"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#proposal"}},[e._v("#")]),e._v(" Proposal")]),e._v(" "),s("p",[e._v("We propose to deprecate two existing instructions—"),s("code",[e._v("JUMP")]),e._v(" and "),s("code",[e._v("JUMPI")]),e._v("—and propose new instructions to support their legitimate uses.  In particular, it must remain possible to compile Solidity and Vyper code to EVM bytecode, with no significant loss of performance or increase in gas price.")]),e._v(" "),s("p",[e._v("Especially important is efficient translation to and from "),s("a",{attrs:{href:"https://github.com/ewasm/design",target:"_blank",rel:"noopener noreferrer"}},[e._v("eWasm"),s("OutboundLink")],1),e._v(" and to machine code.  To that end we maintain a close correspondence between "),s("a",{attrs:{href:"https://webassembly.github.io/spec/core/_download/WebAssembly.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Wasm"),s("OutboundLink")],1),e._v(", "),s("a",{attrs:{href:"https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("x86"),s("OutboundLink")],1),e._v(", "),s("a",{attrs:{href:"https://static.docs.arm.com/100076/0100/arm_instruction_set_reference_guide_100076_0100_00_en.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("ARM"),s("OutboundLink")],1),e._v(" and proposed EVM instructions.")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("EIP-615")]),e._v(" "),s("th",[e._v("Wasm")]),e._v(" "),s("th",[e._v("x86")]),e._v(" "),s("th",[e._v("ARM")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("JUMPTO")]),e._v(" "),s("td",[e._v("br")]),e._v(" "),s("td",[e._v("JMP")]),e._v(" "),s("td",[e._v("B")])]),e._v(" "),s("tr",[s("td",[e._v("JUMPIF")]),e._v(" "),s("td",[e._v("br_if")]),e._v(" "),s("td",[e._v("JE")]),e._v(" "),s("td",[e._v("BEQ")])]),e._v(" "),s("tr",[s("td",[e._v("JUMPV")]),e._v(" "),s("td",[e._v("br_table")]),e._v(" "),s("td",[e._v("JMP")]),e._v(" "),s("td",[e._v("TBH")])]),e._v(" "),s("tr",[s("td",[e._v("JUMPSUB")]),e._v(" "),s("td",[e._v("call")]),e._v(" "),s("td",[e._v("CALL")]),e._v(" "),s("td",[e._v("BL")])]),e._v(" "),s("tr",[s("td",[e._v("JUMPSUBV")]),e._v(" "),s("td",[e._v("call_indirect")]),e._v(" "),s("td",[e._v("CALL")]),e._v(" "),s("td",[e._v("BL")])]),e._v(" "),s("tr",[s("td",[e._v("RETURN")]),e._v(" "),s("td",[e._v("return")]),e._v(" "),s("td",[e._v("RET")]),e._v(" "),s("td",[e._v("RET")])]),e._v(" "),s("tr",[s("td",[e._v("GETLOCAL")]),e._v(" "),s("td",[e._v("local.get")]),e._v(" "),s("td",[e._v("POP")]),e._v(" "),s("td",[e._v("POP")])]),e._v(" "),s("tr",[s("td",[e._v("PUTLOCAL")]),e._v(" "),s("td",[e._v("local.put")]),e._v(" "),s("td",[e._v("PUSH")]),e._v(" "),s("td",[e._v("PUSH")])]),e._v(" "),s("tr",[s("td",[e._v("BEGINSUB")]),e._v(" "),s("td",[e._v("func")]),e._v(" "),s("td"),e._v(" "),s("td")]),e._v(" "),s("tr",[s("td",[e._v("BEGINDATA")]),e._v(" "),s("td",[e._v("tables")]),e._v(" "),s("td"),e._v(" "),s("td")])])]),e._v(" "),s("h4",{attrs:{id:"preliminaries"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#preliminaries"}},[e._v("#")]),e._v(" Preliminaries")]),e._v(" "),s("p",[e._v("These forms")]),e._v(" "),s("blockquote",[s("p",[s("em",[s("code",[e._v("INSTRUCTION")])])]),e._v(" "),s("p",[s("em",[s("code",[e._v("INSTRUCTION x")])])]),e._v(" "),s("p",[s("em",[s("code",[e._v("INSTRUCTION x, y")])])])]),e._v(" "),s("p",[e._v("name an "),s("em",[s("code",[e._v("INSTRUCTION")])]),e._v(" with no, one and two arguments, respectively. An instruction is represented in the bytecode as a single-byte opcode. Any arguments are laid out as immediate data bytes following the opcode inline, interpreted as fixed length, MSB-first, two's-complement, two-byte positive integers. (Negative values are reserved for extensions.)")]),e._v(" "),s("h4",{attrs:{id:"branches-and-subroutines"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#branches-and-subroutines"}},[e._v("#")]),e._v(" Branches and Subroutines")]),e._v(" "),s("p",[e._v("The two most important uses of "),s("code",[e._v("JUMP")]),e._v(" and "),s("code",[e._v("JUMPI")]),e._v(" are static jumps and return jumps. Conditional and unconditional static jumps are the mainstay of control flow.  Return jumps are implemented as a dynamic jump to a return address pushed on the stack.  With the combination of a static jump and a dynamic return jump you can—and Solidity does—implement subroutines.  The problem is that static analysis cannot tell the one place the return jump is going, so it must analyze every possibility (a heavy analysis).")]),e._v(" "),s("p",[e._v("Static jumps are provided by")]),e._v(" "),s("blockquote",[s("p",[s("code",[e._v("JUMPTO jump_target")])]),e._v(" "),s("p",[s("code",[e._v("JUMPIF jump_target")])]),e._v(" "),s("p",[e._v("which are the same as "),s("code",[e._v("JUMP")]),e._v(" and "),s("code",[e._v("JUMPI")]),e._v(" except that they jump to an immediate "),s("code",[e._v("jump_target")]),e._v(" rather than an address on the stack.")])]),e._v(" "),s("p",[e._v("To support subroutines, "),s("code",[e._v("BEGINSUB")]),e._v(", "),s("code",[e._v("JUMPSUB")]),e._v(", and "),s("code",[e._v("RETURNSUB")]),e._v(" are provided.  Brief descriptions follow, and full semantics are given below.")]),e._v(" "),s("blockquote",[s("p",[s("code",[e._v("BEGINSUB n_args, n_results")])]),e._v(" "),s("p",[e._v("marks the "),s("strong",[e._v("single")]),e._v(" entry to a subroutine.  "),s("code",[e._v("n_args")]),e._v(" items are taken off of the stack at entry to, and "),s("code",[e._v("n_results")]),e._v(" items are placed on the stack at return from the subroutine.   The subroutine ends at the next "),s("code",[e._v("BEGINSUB")]),e._v(" instruction (or "),s("code",[e._v("BEGINDATA")]),e._v(", below) or at the end of the bytecode.")])]),e._v(" "),s("blockquote",[s("p",[s("code",[e._v("JUMPSUB jump_target")])]),e._v(" "),s("p",[e._v("jumps to an immediate subroutine address.")])]),e._v(" "),s("blockquote",[s("p",[s("code",[e._v("RETURNSUB")])]),e._v(" "),s("p",[e._v("returns from the current subroutine to the instruction following the JUMPSUB that entered it.")])]),e._v(" "),s("h4",{attrs:{id:"switches-callbacks-and-virtual-functions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#switches-callbacks-and-virtual-functions"}},[e._v("#")]),e._v(" Switches, Callbacks, and Virtual Functions")]),e._v(" "),s("p",[e._v("Dynamic jumps are also used for "),s("code",[e._v("O(1)")]),e._v(" indirection: an address to jump to is selected to push on the stack and be jumped to.  So we also propose two more instructions to provide for constrained indirection.  We support these with vectors of "),s("code",[e._v("JUMPDEST")]),e._v(" or "),s("code",[e._v("BEGINSUB")]),e._v(" offsets stored inline, which can be selected with an index on the stack.  That constrains validation to a specified subset of all possible destinations.  The danger of quadratic blow up is avoided because it takes as much space to store the jump vectors as it does to code the worst case exploit.")]),e._v(" "),s("p",[e._v("Dynamic jumps to a "),s("code",[e._v("JUMPDEST")]),e._v(" are used to implement "),s("code",[e._v("O(1)")]),e._v(" jumptables, which are useful for dense switch statements.  Wasm and most CPUs provide similar instructions.")]),e._v(" "),s("blockquote",[s("p",[s("code",[e._v("JUMPV n, jump_targets")])]),e._v(" "),s("p",[e._v("jumps to one of a vector of "),s("code",[e._v("n")]),e._v(" "),s("code",[e._v("JUMPDEST")]),e._v(" offsets via a zero-based index on the stack.  The vector is stored inline at the "),s("code",[e._v("jump_targets")]),e._v(" offset after the BEGINDATA bytecode as MSB-first, two's-complement, two-byte positive integers.  If the index is greater than or equal to "),s("code",[e._v("n - 1")]),e._v(" the last (default) offset is used.")])]),e._v(" "),s("p",[e._v("Dynamic jumps to a "),s("code",[e._v("BEGINSUB")]),e._v(" are used to implement "),s("code",[e._v("O(1)")]),e._v(" virtual functions and callbacks, which take at most two pointer dereferences on most CPUs.   Wasm provides a similar instruction.")]),e._v(" "),s("blockquote",[s("p",[s("code",[e._v("JUMPSUBV n, jump_targets")])]),e._v(" "),s("p",[e._v("jumps to one of a vector of "),s("code",[e._v("n")]),e._v(" "),s("code",[e._v("BEGINSUB")]),e._v(" offsets via a zero-based index on the stack.  The vector is stored inline at the "),s("code",[e._v("jump_targets")]),e._v(" offset after the DATA bytecode, as MSB-first, two's-complement, two-byte positive integers.  If the index is greater than or equal to "),s("code",[e._v("n - 1")]),e._v(" the last (default) offset is used.")])]),e._v(" "),s("h4",{attrs:{id:"variable-access"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#variable-access"}},[e._v("#")]),e._v(" Variable Access")]),e._v(" "),s("p",[e._v("These operations provide convenient access to subroutine parameters and local variables at fixed stack offsets within a subroutine.  Otherwise only sixteen variables can be directly addressed.")]),e._v(" "),s("blockquote",[s("p",[s("code",[e._v("PUTLOCAL n")])]),e._v(" "),s("p",[e._v("Pops the stack to the local variable "),s("code",[e._v("n")]),e._v(".")])]),e._v(" "),s("blockquote",[s("p",[s("code",[e._v("GETLOCAL n")])]),e._v(" "),s("p",[e._v("Pushes the local variable "),s("code",[e._v("n")]),e._v(" onto the stack.")])]),e._v(" "),s("p",[e._v("Local variable "),s("code",[e._v("n")]),e._v(" is the nth stack item below the frame pointer, "),s("code",[e._v("FP[-n]")]),e._v(", as defined below.")]),e._v(" "),s("h4",{attrs:{id:"data"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#data"}},[e._v("#")]),e._v(" Data")]),e._v(" "),s("p",[e._v("There needs to be a way to place unreachable data into the bytecode that will be skipped over and not validated.  Indirect jump vectors will not be valid code.  Initialization code must create runtime code from data that might not be valid code.  And unreachable data might prove useful to programs for other purposes.")]),e._v(" "),s("blockquote",[s("p",[s("code",[e._v("BEGINDATA")])]),e._v(" "),s("p",[e._v("specifies that all of the following bytes to the end of the bytecode are data, and not reachable code.")])]),e._v(" "),s("h4",{attrs:{id:"structure"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#structure"}},[e._v("#")]),e._v(" Structure")]),e._v(" "),s("p",[e._v("Valid EIP-615 EVM bytecode begins with a valid header.  This is the magic number  ‘\\0evm’ followed by the semantic versioning number '\\1\\5\\0'.  (For Wasm the header is '\\0asm\\1').")]),e._v(" "),s("p",[e._v("Following the header is the BEGINSUB opcode for the "),s("em",[e._v("main")]),e._v(" routine.  It takes no arguments and returns no values.  Other subroutines may follow the "),s("em",[e._v("main")]),e._v(" routine, and an optional BEGINDATA opcode may mark the start of a data section.")]),e._v(" "),s("h3",{attrs:{id:"semantics"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#semantics"}},[e._v("#")]),e._v(" Semantics")]),e._v(" "),s("p",[e._v("Jumps to and returns from subroutines are described here in terms of")]),e._v(" "),s("ul",[s("li",[e._v("The EVM data stack, (as defined in the "),s("a",{attrs:{href:"https://ethereum.github.io/yellowpaper/paper.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Yellow Paper"),s("OutboundLink")],1),e._v(") usually just called “the stack.”")]),e._v(" "),s("li",[e._v("A return stack of "),s("code",[e._v("JUMPSUB")]),e._v(" and "),s("code",[e._v("JUMPSUBV")]),e._v(" offsets.")]),e._v(" "),s("li",[e._v("A frame stack of frame pointers.")])]),e._v(" "),s("p",[e._v("We will adopt the following conventions to describe the machine state:")]),e._v(" "),s("ul",[s("li",[e._v("The "),s("em",[e._v("program counter")]),e._v(" "),s("code",[e._v("PC")]),e._v(" is (as usual) the byte offset of the currently executing instruction.")]),e._v(" "),s("li",[e._v("The "),s("em",[e._v("stack pointer")]),e._v(" "),s("code",[e._v("SP")]),e._v(" corresponds to the "),s("a",{attrs:{href:"https://ethereum.github.io/yellowpaper/paper.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Yellow Paper"),s("OutboundLink")],1),e._v("'s substate "),s("code",[e._v("s")]),e._v(" of the machine state.\n"),s("ul",[s("li",[s("code",[e._v("SP[0]")]),e._v(" is where a new item is can be pushed on the stack.")]),e._v(" "),s("li",[s("code",[e._v("SP[1]")]),e._v(" is the first item on the stack, which can be popped off the stack.")]),e._v(" "),s("li",[e._v("The stack grows towards lower addresses.")])])]),e._v(" "),s("li",[e._v("The "),s("em",[e._v("frame pointer")]),e._v(" "),s("code",[e._v("FP")]),e._v(" is set to "),s("code",[e._v("SP + n_args")]),e._v(" at entry to the currently executing subroutine.\n"),s("ul",[s("li",[e._v("The "),s("em",[e._v("stack items")]),e._v(" between the frame pointer and the current stack pointer are called the "),s("em",[e._v("frame")]),e._v(".")]),e._v(" "),s("li",[e._v("The current number of items in the frame, "),s("code",[e._v("FP - SP")]),e._v(", is the "),s("em",[e._v("frame size")]),e._v(".")])])])]),e._v(" "),s("blockquote",[s("p",[s("strong",[e._v("Note")]),e._v(": Defining the frame pointer so as to include the arguments is unconventional, but better fits our stack semantics and simplifies the remainder of the proposal.")])]),e._v(" "),s("p",[e._v("The frame pointer and return stacks are internal to the subroutine mechanism, and not directly accessible to the program.  This is necessary to prevent the program from modifying its own state in ways that could be invalid.")]),e._v(" "),s("p",[e._v("Execution of EVM bytecode begins with the "),s("em",[e._v("main")]),e._v(" routine with no arguments, "),s("code",[e._v("SP")]),e._v(" and "),s("code",[e._v("FP")]),e._v(" set to 0, and with one value on the return stack—"),s("code",[e._v("code_size - 1")]),e._v(". (Executing the virtual byte of 0 after this offset causes an EVM to stop.  Thus executing a "),s("code",[e._v("RETURNSUB")]),e._v(" with no prior "),s("code",[e._v("JUMPSUB")]),e._v(" or "),s("code",[e._v("JUMBSUBV")]),e._v("—that is, in the "),s("em",[e._v("main")]),e._v(" routine—executes a "),s("code",[e._v("STOP")]),e._v(".)")]),e._v(" "),s("p",[e._v("Execution of a subroutine begins with "),s("code",[e._v("JUMPSUB")]),e._v(" or "),s("code",[e._v("JUMPSUBV")]),e._v(", which")]),e._v(" "),s("ul",[s("li",[e._v("pushes "),s("code",[e._v("PC")]),e._v(" on the return stack,")]),e._v(" "),s("li",[e._v("pushes "),s("code",[e._v("FP")]),e._v(" on the frame stack\n"),s("ul",[s("li",[e._v("thus suspending execution of the current subroutine,")])])]),e._v(" "),s("li",[e._v("sets "),s("code",[e._v("FP")]),e._v(" to "),s("code",[e._v("SP + n_args")]),e._v(", and")]),e._v(" "),s("li",[e._v("sets "),s("code",[e._v("PC")]),e._v(" to the specified "),s("code",[e._v("BEGINSUB")]),e._v(" address\n"),s("ul",[s("li",[e._v("thus beginning execution of the new subroutine.")])])])]),e._v(" "),s("p",[e._v("Execution of a subroutine is suspended during and resumed after execution of nested subroutines, and ends upon encountering a "),s("code",[e._v("RETURNSUB")]),e._v(", which")]),e._v(" "),s("ul",[s("li",[e._v("sets "),s("code",[e._v("FP")]),e._v(" to the top of the virtual frame stack and pops the stack,")]),e._v(" "),s("li",[e._v("sets "),s("code",[e._v("SP")]),e._v(" to "),s("code",[e._v("FP + n_results")]),e._v(",")]),e._v(" "),s("li",[e._v("sets "),s("code",[e._v("PC")]),e._v(" to top of the return stack and pops the stack, and")]),e._v(" "),s("li",[e._v("advances "),s("code",[e._v("PC")]),e._v(" to the next instruction")])]),e._v(" "),s("p",[e._v("thus resuming execution of the enclosing subroutine or "),s("em",[e._v("main")]),e._v(" routine.  A "),s("code",[e._v("STOP")]),e._v(" or "),s("code",[e._v("RETURN")]),e._v(" also ends the execution of a subroutine.")]),e._v(" "),s("p",[e._v("For example, starting from this stack,")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("_________________\n      | locals      20 <- FP\nframe |             21\n______|___________  22\n                       <- SP\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("p",[e._v("and after pushing two arguments and branching with "),s("code",[e._v("JUMPSUB")]),e._v(" to a "),s("code",[e._v("BEGINSUB 2, 3")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("PUSH 10\nPUSH 11\nJUMPSUB beginsub\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("p",[e._v("and initializing three local variables")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("PUSH 99\nPUSH 98\nPUSH 97\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("p",[e._v("the stack looks like this")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("                    20\n                    21\n__________________  22\n      | arguments   10 <- FP\nframe |___________  11\n      | locals      99\n      |             98\n______|___________  97\n                       <- SP\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br")])]),s("p",[e._v("After some amount of computation the stack could look like this")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("                    20\n                    21\n__________________  22\n      | returns     44 <- FP\n      |             43\nframe |___________  42\n      | locals      13\n______|___________  14\n                       <- SP\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br")])]),s("p",[e._v("and after "),s("code",[e._v("RETURNSUB")]),e._v(" would look like this")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("_________________\n      | locals      20 <- FP\n      |             21\nframe |___________  22\n      | returns     44\n      |             43\n______|___________  42\n                       <- SP\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br")])]),s("h3",{attrs:{id:"validity"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#validity"}},[e._v("#")]),e._v(" Validity")]),e._v(" "),s("p",[e._v("We would like to consider EVM code valid iff no execution of the program can lead to an exceptional halting state, but we must validate code in linear time. So our validation does not consider the code’s data and computations, only its control flow and stack use.  This means we will reject programs with invalid code paths, even if those paths are not reachable.  Most conditions can be validated, and will not need to be checked at runtime; the exceptions are sufficient gas and sufficient stack.  As such, static analysis may yield false negatives belonging to well-understood classes of code requiring runtime checks.  Aside from those cases, we can validate large classes at validation time and with linear complexity.")]),e._v(" "),s("p",[s("em",[e._v("Execution")]),e._v(" is as defined in the "),s("a",{attrs:{href:"https://ethereum.github.io/yellowpaper/paper.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Yellow Paper"),s("OutboundLink")],1),e._v("—a sequence of changes in the EVM state.  The conditions on valid code are preserved by state changes.  At runtime, if execution of an instruction would violate a condition the execution is in an exceptional halting state.  The Yellow Paper defines five such states.")]),e._v(" "),s("blockquote",[s("p",[s("strong",[e._v("1")]),e._v("  Insufficient gas")])]),e._v(" "),s("blockquote",[s("p",[s("strong",[e._v("2")]),e._v("  More than 1024 stack items")])]),e._v(" "),s("blockquote",[s("p",[s("strong",[e._v("3")]),e._v("  Insufficient stack items")])]),e._v(" "),s("blockquote",[s("p",[s("strong",[e._v("4")]),e._v("  Invalid jump destination")])]),e._v(" "),s("blockquote",[s("p",[s("strong",[e._v("5")]),e._v("  Invalid instruction")])]),e._v(" "),s("p",[e._v("We propose to expand and extend the Yellow Paper conditions to handle the new instructions we propose.")]),e._v(" "),s("p",[e._v("To handle the return stack we expand the conditions on stack size:")]),e._v(" "),s("blockquote",[s("p",[s("strong",[e._v("2a")]),e._v("  The size of the data stack does not exceed 1024.")])]),e._v(" "),s("blockquote",[s("p",[s("strong",[e._v("2b")]),e._v("  The size of the return stack does not exceed 1024.")])]),e._v(" "),s("p",[e._v("Given our more detailed description of the data stack we restate condition 3—stack underflow—as")]),e._v(" "),s("blockquote",[s("p",[s("strong",[e._v("3")]),e._v(" "),s("code",[e._v("SP")]),e._v(" must be less than or equal to "),s("code",[e._v("FP")])])]),e._v(" "),s("p",[e._v("Since the various "),s("code",[e._v("DUP")]),e._v(" and "),s("code",[e._v("SWAP")]),e._v(" operations—as well as "),s("code",[e._v("PUTLOCAL")]),e._v(" and "),s("code",[e._v("GETLOCAL")]),e._v("—are defined as taking items off the stack and putting them back on, this prevents them from accessing data below the frame pointer, since taking too many items off of the stack would mean that "),s("code",[e._v("SP")]),e._v(" is less than "),s("code",[e._v("FP")]),e._v(".")]),e._v(" "),s("p",[e._v("To handle the new jump instructions and subroutine boundaries, we expand the conditions on jumps and jump destinations.")]),e._v(" "),s("blockquote",[s("p",[s("strong",[e._v("4a")]),e._v(" "),s("code",[e._v("JUMPTO")]),e._v(", "),s("code",[e._v("JUMPIF")]),e._v(", and "),s("code",[e._v("JUMPV")]),e._v(" address only "),s("code",[e._v("JUMPDEST")]),e._v(" instructions.")])]),e._v(" "),s("blockquote",[s("p",[s("strong",[e._v("4b")]),e._v(" "),s("code",[e._v("JUMPSUB")]),e._v(" and "),s("code",[e._v("JUMPSUBV")]),e._v(" address only "),s("code",[e._v("BEGINSUB")]),e._v(" instructions.")])]),e._v(" "),s("blockquote",[s("p",[s("strong",[e._v("4c")]),e._v(" "),s("code",[e._v("JUMP")]),e._v(" instructions do not address instructions outside of the subroutine they occur in.")])]),e._v(" "),s("p",[e._v("We have two new conditions on execution to ensure consistent use of the stack by subroutines:")]),e._v(" "),s("blockquote",[s("p",[s("strong",[e._v("6")]),e._v("  For "),s("code",[e._v("JUMPSUB")]),e._v(" and "),s("code",[e._v("JUMPSUBV")]),e._v(" the frame size is at least the "),s("code",[e._v("n_args")]),e._v(" of the "),s("code",[e._v("BEGINSUB")]),e._v("(s) to jump to.")])]),e._v(" "),s("blockquote",[s("p",[s("strong",[e._v("7")]),e._v("  For "),s("code",[e._v("RETURNSUB")]),e._v(" the frame size is equal to the "),s("code",[e._v("n_results")]),e._v(" of the enclosing "),s("code",[e._v("BEGINSUB")]),e._v(".")])]),e._v(" "),s("p",[e._v("Finally, we have one condition that prevents pathological uses of the stack:")]),e._v(" "),s("blockquote",[s("p",[s("strong",[e._v("8")]),e._v("  For every instruction in the code the frame size is constant.")])]),e._v(" "),s("p",[e._v("In practice, we must test at runtime for conditions 1 and 2—sufficient gas and sufficient stack.  We don’t know how much gas there will be, we don’t know how deep a recursion may go, and analysis of stack depth even for non-recursive programs is nontrivial.")]),e._v(" "),s("p",[e._v("All of the remaining conditions we validate statically.")]),e._v(" "),s("h4",{attrs:{id:"costs-codes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#costs-codes"}},[e._v("#")]),e._v(" Costs & Codes")]),e._v(" "),s("p",[e._v("All of the instructions are "),s("code",[e._v("O(1)")]),e._v(" with a small constant, requiring just a few machine operations each, whereas a "),s("code",[e._v("JUMP")]),e._v(" or "),s("code",[e._v("JUMPI")]),e._v(" typically does an "),s("code",[e._v("O(log n)")]),e._v(" binary search of an array of "),s("code",[e._v("JUMPDEST")]),e._v(" offsets before every jump. With the cost of "),s("code",[e._v("JUMPI")]),e._v(" being "),s("em",[e._v("high")]),e._v(" and the cost of "),s("code",[e._v("JUMP")]),e._v(" being "),s("em",[e._v("mid")]),e._v(", we suggest the cost of "),s("code",[e._v("JUMPV")]),e._v(" and "),s("code",[e._v("JUMPSUBV")]),e._v(" should be "),s("em",[e._v("mid")]),e._v(", "),s("code",[e._v("JUMPSUB")]),e._v(" and "),s("code",[e._v("JUMPIF")]),e._v(" should be "),s("em",[e._v("low")]),e._v(", and"),s("code",[e._v("JUMPTO")]),e._v(" and the rest should be "),s("em",[e._v("verylow")]),e._v(".  Measurement will tell.")]),e._v(" "),s("p",[e._v("We suggest the following opcodes:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("0xb0 JUMPTO\n0xb1 JUMPIF\n0xb2 JUMPV\n0xb3 JUMPSUB\n0xb4 JUMPSUBV\n0xb5 BEGINSUB\n0xb6 BEGINDATA\n0xb7 RETURNSUB\n0xb8 PUTLOCAL\n0xb9 GETLOCAL\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br")])]),s("h2",{attrs:{id:"backwards-compatibility"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),s("p",[e._v("These changes would need to be implemented in phases at decent intervals:")]),e._v(" "),s("blockquote",[s("p",[s("strong",[e._v("1.")]),e._v("  If this EIP is accepted, invalid code should be deprecated. Tools should stop generating invalid code, users should stop writing it, and clients should warn about loading it.")])]),e._v(" "),s("blockquote",[s("p",[s("strong",[e._v("2.")]),e._v("  A later hard fork would require clients to place only valid code on the block chain.  Note that despite the fork old EVM code will still need to be supported indefinitely; older contracts will continue to run, and to create new contracts.")])]),e._v(" "),s("p",[e._v("If desired, the period of deprecation can be extended indefinitely by continuing to accept code not versioned as new—but without validation.  That is, by delaying or canceling phase 2.")]),e._v(" "),s("p",[e._v("Regardless, we will need a versioning scheme like "),s("RouterLink",{attrs:{to:"/eip-1702.html"}},[e._v("EIP-1702")]),e._v(" to allow current code and EIP-615 code to coexist on the same blockchain.")],1),e._v(" "),s("h2",{attrs:{id:"rationale"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),s("p",[e._v("This design was highly constrained by the existing EVM semantics, the requirement for eWasm compatibility, and the security demands of the Ethereum environment.  It was also informed by the lead author's previous work implementing Java and Scheme interpreters.  As such there was very little room for alternative designs.")]),e._v(" "),s("p",[e._v("As described above, the approach was simply to deprecate the problematic dynamic jumps, then ask what opcodes were necessary to provide for the features they supported.  These needed to include those provided by eWasm, which themselves were modeled after typical hardware.  The only real innovation was to move the frame pointer and the return pointer to their own stacks, so as to prevent any possibility of overwriting them. (Although Forth also uses a return stack.)  This allowed for treating subroutine arguments as local variables, and facilitated the return of multiple values.")]),e._v(" "),s("h2",{attrs:{id:"implementation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),s("p",[e._v("Implementation of this proposal need not be difficult.  At the least, interpreters can simply be extended with the new opcodes and run unchanged otherwise.  The new opcodes require only stacks for the frame pointers and return offsets and the few pushes, pops, and assignments described above. The bulk of the effort is the validator, which in most languages can almost be transcribed from the pseudocode above.")]),e._v(" "),s("p",[e._v("A lightly tested C++ reference implementation is available in "),s("a",{attrs:{href:"https://github.com/gcolvin/aleth/tree/master/libaleth-interpreter",target:"_blank",rel:"noopener noreferrer"}},[e._v("Greg Colvin's Aleth fork."),s("OutboundLink")],1),e._v("  This version required circa 110 lines of new interpreter code and a well-commented, 178-line validator.")]),e._v(" "),s("h2",{attrs:{id:"appendix-a"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#appendix-a"}},[e._v("#")]),e._v(" Appendix A")]),e._v(" "),s("h3",{attrs:{id:"validation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#validation"}},[e._v("#")]),e._v(" Validation")]),e._v(" "),s("p",[e._v("Validation comprises two tasks:")]),e._v(" "),s("ul",[s("li",[e._v("Check that jump destinations are correct and instructions valid.")]),e._v(" "),s("li",[e._v("Check that subroutines satisfy the conditions on control flow and stack use.")])]),e._v(" "),s("p",[e._v("We sketch out these two validation functions in pseudo-C below.  To simplify the presentation only the five primitives are handled ("),s("code",[e._v("JUMPV")]),e._v(" and "),s("code",[e._v("JUMPSUBV")]),e._v(" would just add more complexity to loop over their vectors), we assume helper functions for extracting instruction arguments from immediate data and managing the stack pointer and program counter, and some optimizations are forgone.")]),e._v(" "),s("h4",{attrs:{id:"validating-jumps"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#validating-jumps"}},[e._v("#")]),e._v(" Validating Jumps")]),e._v(" "),s("p",[e._v("Validating that jumps are to valid addresses takes two sequential passes over the bytecode—one to build sets of jump destinations and subroutine entry points, another to check that addresses jumped to are in the appropriate sets.")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    bytecode[code_size]   // contains EVM bytecode to validate\n    is_sub[code_size]     // is there a BEGINSUB at PC?\n    is_dest[code_size]    // is there a JUMPDEST at PC?\n    sub_for_pc[code_size] // which BEGINSUB is PC in?\n\n    bool validate_jumps(PC)\n    {\n        current_sub = PC\n\n        // build sets of BEGINSUBs and JUMPDESTs\n        for (PC = 0; instruction = bytecode[PC]; PC = advance_pc(PC))\n        {\n            if instruction is invalid\n                return false\n            if instruction is BEGINDATA\n                break;\n            if instruction is BEGINSUB\n                is_sub[PC] = true\n                current_sub = PC\n                sub_for_pc[PC] = current_sub\n            if instruction is JUMPDEST\n                is_dest[PC] = true\n            sub_for_pc[PC] = current_sub\n        }\n\n        // check that targets are in subroutine\n        for (PC = 0; instruction = bytecode[PC]; PC = advance_pc(PC))\n        {\n            if instruction is BEGINDATA\n                break;\n            if instruction is BEGINSUB\n                current_sub = PC\n            if instruction is JUMPSUB\n                if is_sub[jump_target(PC)] is false\n                    return false\n            if instruction is JUMPTO or JUMPIF\n                if is_dest[jump_target(PC)] is false\n                    return false\n            if sub_for_pc[PC] is not current_sub\n                return false\n       }\n       return true\n    }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br"),s("span",{staticClass:"line-number"},[e._v("37")]),s("br"),s("span",{staticClass:"line-number"},[e._v("38")]),s("br"),s("span",{staticClass:"line-number"},[e._v("39")]),s("br"),s("span",{staticClass:"line-number"},[e._v("40")]),s("br"),s("span",{staticClass:"line-number"},[e._v("41")]),s("br"),s("span",{staticClass:"line-number"},[e._v("42")]),s("br"),s("span",{staticClass:"line-number"},[e._v("43")]),s("br")])]),s("p",[e._v("Note that code like this is already run by EVMs to check dynamic jumps, including building the jump destination set every time a contract is run, and doing a lookup in the jump destination set before every jump.")]),e._v(" "),s("h4",{attrs:{id:"subroutine-validation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#subroutine-validation"}},[e._v("#")]),e._v(" Subroutine Validation")]),e._v(" "),s("p",[e._v("This function can be seen as a symbolic execution of a subroutine in the EVM code, where only the effect of the instructions on the state being validated is computed.  Thus the structure of this function is very similar to an EVM interpreter.  This function can also be seen as an acyclic traversal of the directed graph formed by taking instructions as vertices and sequential and branching connections as edges, checking conditions along the way.  The traversal is accomplished via recursion, and cycles are broken by returning when a vertex which has already been visited is reached.  The time complexity of this traversal is "),s("code",[e._v("O(|E|+|V|)")]),e._v(": The sum of the number of edges and number of vertices in the graph.")]),e._v(" "),s("p",[e._v("The basic approach is to call "),s("code",[e._v("validate_subroutine(i, 0, 0)")]),e._v(", for "),s("code",[e._v("i")]),e._v(" equal to the first instruction in the EVM code through each "),s("code",[e._v("BEGINDATA")]),e._v(" offset.  "),s("code",[e._v("validate_subroutine()")]),e._v(" traverses instructions sequentially, recursing when "),s("code",[e._v("JUMP")]),e._v(" and "),s("code",[e._v("JUMPI")]),e._v(" instructions are encountered.  When a destination is reached that has been visited before it returns, thus breaking cycles.  It returns true if the subroutine is valid, false otherwise.")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    bytecode[code_size]     // contains EVM bytecode to validate\n    frame_size[code_size ]  // is filled with -1\n\n    // we validate each subroutine individually, as if at top level\n    // * PC is the offset in the code to start validating at\n    // * return_pc is the top PC on return stack that RETURNSUB returns to\n    // * at top level FP = SP = 0 is both the frame size and the stack size\n    // * as items are pushed SP get more negative, so the stack size is -SP\n    validate_subroutine(PC, return_pc, SP)\n    {\n        // traverse code sequentially, recurse for jumps\n        while true\n        {\n            instruction = bytecode[PC]\n\n            // if frame size set we have been here before\n            if frame_size[PC] >= 0\n            {\n                // check for constant frame size\n                if instruction is JUMPDEST\n                    if -SP != frame_size[PC]\n                        return false\n\n                // return to break cycle\n                return true\n            }\n            frame_size[PC] = -SP\n\n            // effect of instruction on stack\n            n_removed = removed_items(instructions)\n            n_added = added_items(instruction)\n\n            // check for stack underflow\n            if -SP < n_removed\n                return false\n\n            // net effect of removing and adding stack items\n            SP += n_removed\n            SP -= n_added\n\n            // check for stack overflow\n            if -SP > 1024\n                return false\n\n            if instruction is STOP, RETURN, or SUICIDE\n                return true\n\n            // violates single entry\n            if instruction is BEGINSUB\n                 return false\n\n            // return to top or from recursion to JUMPSUB\n            if instruction is RETURNSUB\n                return true;;\n\n            if instruction is JUMPSUB\n            {\n                // check for enough arguments\n                sub_pc = jump_target(PC)\n                if -SP < n_args(sub_pc)\n                    return false\n                return true\n            }\n\n            // reset PC to destination of jump\n            if instruction is JUMPTO\n            {\n                PC = jump_target(PC)\n                continue\n            }\n\n            // recurse to jump to code to validate\n            if instruction is JUMPIF\n            {\n                if not validate_subroutine(jump_target(PC), return_pc, SP)\n                    return false\n            }\n\n            // advance PC according to instruction\n            PC = advance_pc(PC)\n        }\n\n        // check for right number of results\n        if (-SP != n_results(return_pc)\n            return false\n        return true\n    }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br"),s("span",{staticClass:"line-number"},[e._v("37")]),s("br"),s("span",{staticClass:"line-number"},[e._v("38")]),s("br"),s("span",{staticClass:"line-number"},[e._v("39")]),s("br"),s("span",{staticClass:"line-number"},[e._v("40")]),s("br"),s("span",{staticClass:"line-number"},[e._v("41")]),s("br"),s("span",{staticClass:"line-number"},[e._v("42")]),s("br"),s("span",{staticClass:"line-number"},[e._v("43")]),s("br"),s("span",{staticClass:"line-number"},[e._v("44")]),s("br"),s("span",{staticClass:"line-number"},[e._v("45")]),s("br"),s("span",{staticClass:"line-number"},[e._v("46")]),s("br"),s("span",{staticClass:"line-number"},[e._v("47")]),s("br"),s("span",{staticClass:"line-number"},[e._v("48")]),s("br"),s("span",{staticClass:"line-number"},[e._v("49")]),s("br"),s("span",{staticClass:"line-number"},[e._v("50")]),s("br"),s("span",{staticClass:"line-number"},[e._v("51")]),s("br"),s("span",{staticClass:"line-number"},[e._v("52")]),s("br"),s("span",{staticClass:"line-number"},[e._v("53")]),s("br"),s("span",{staticClass:"line-number"},[e._v("54")]),s("br"),s("span",{staticClass:"line-number"},[e._v("55")]),s("br"),s("span",{staticClass:"line-number"},[e._v("56")]),s("br"),s("span",{staticClass:"line-number"},[e._v("57")]),s("br"),s("span",{staticClass:"line-number"},[e._v("58")]),s("br"),s("span",{staticClass:"line-number"},[e._v("59")]),s("br"),s("span",{staticClass:"line-number"},[e._v("60")]),s("br"),s("span",{staticClass:"line-number"},[e._v("61")]),s("br"),s("span",{staticClass:"line-number"},[e._v("62")]),s("br"),s("span",{staticClass:"line-number"},[e._v("63")]),s("br"),s("span",{staticClass:"line-number"},[e._v("64")]),s("br"),s("span",{staticClass:"line-number"},[e._v("65")]),s("br"),s("span",{staticClass:"line-number"},[e._v("66")]),s("br"),s("span",{staticClass:"line-number"},[e._v("67")]),s("br"),s("span",{staticClass:"line-number"},[e._v("68")]),s("br"),s("span",{staticClass:"line-number"},[e._v("69")]),s("br"),s("span",{staticClass:"line-number"},[e._v("70")]),s("br"),s("span",{staticClass:"line-number"},[e._v("71")]),s("br"),s("span",{staticClass:"line-number"},[e._v("72")]),s("br"),s("span",{staticClass:"line-number"},[e._v("73")]),s("br"),s("span",{staticClass:"line-number"},[e._v("74")]),s("br"),s("span",{staticClass:"line-number"},[e._v("75")]),s("br"),s("span",{staticClass:"line-number"},[e._v("76")]),s("br"),s("span",{staticClass:"line-number"},[e._v("77")]),s("br"),s("span",{staticClass:"line-number"},[e._v("78")]),s("br"),s("span",{staticClass:"line-number"},[e._v("79")]),s("br"),s("span",{staticClass:"line-number"},[e._v("80")]),s("br"),s("span",{staticClass:"line-number"},[e._v("81")]),s("br"),s("span",{staticClass:"line-number"},[e._v("82")]),s("br"),s("span",{staticClass:"line-number"},[e._v("83")]),s("br"),s("span",{staticClass:"line-number"},[e._v("84")]),s("br"),s("span",{staticClass:"line-number"},[e._v("85")]),s("br"),s("span",{staticClass:"line-number"},[e._v("86")]),s("br"),s("span",{staticClass:"line-number"},[e._v("87")]),s("br")])]),s("h2",{attrs:{id:"appendix-b"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#appendix-b"}},[e._v("#")]),e._v(" Appendix B")]),e._v(" "),s("h3",{attrs:{id:"evm-analysis"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#evm-analysis"}},[e._v("#")]),e._v(" EVM Analysis")]),e._v(" "),s("p",[e._v("There is a large and growing ecosystem of researchers, authors, teachers, auditors, and analytic tools--providing software and services focused on the correctness and security of EVM code.  A small sample is given here.")]),e._v(" "),s("h4",{attrs:{id:"some-tools"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#some-tools"}},[e._v("#")]),e._v(" Some Tools")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://contract-library.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Contract Library"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://github.com/ethereum/ethereumj",target:"_blank",rel:"noopener noreferrer"}},[e._v("EthereumJ"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://github.com/exthereum/blockchain",target:"_blank",rel:"noopener noreferrer"}},[e._v("Exthereum"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://github.com/ether-camp/ethereum-harmony",target:"_blank",rel:"noopener noreferrer"}},[e._v("Harmony"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://www.pnfsoftware.com/blog/ethereum-smart-contract-decompiler/",target:"_blank",rel:"noopener noreferrer"}},[e._v("JEB"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://github.com/ConsenSys/mythril",target:"_blank",rel:"noopener noreferrer"}},[e._v("Mythril"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://github.com/eth-sri/securify",target:"_blank",rel:"noopener noreferrer"}},[e._v("Securify"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://www.skalelabs.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Skale"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://status.im/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Status"),s("OutboundLink")],1)])]),e._v(" "),s("h4",{attrs:{id:"some-papers"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#some-papers"}},[e._v("#")]),e._v(" Some Papers")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://www.google.com/url?q=http://fsl.cs.illinois.edu/FSL/papers/2018/park-zhang-saxena-daian-rosu-2018-fse/park-zhang-saxena-daian-rosu-2018-fse-public.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("A Formal Verification Tool for Ethereum VM Bytecode"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://github.com/pirapira/eth-isabelle",target:"_blank",rel:"noopener noreferrer"}},[e._v("A Lem formalization of EVM and some Isabelle/HOL proofs"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://eprint.iacr.org/2016/1007.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("A survey of attacks on Ethereum smart contracts"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://www.google.com/url?q=http://fc17.ifca.ai/wtsc/Defining%2520the%2520Ethereum%2520Virtual%2520Machine%2520for%2520Interactive%2520Theorem%2520Provers.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Defining the Ethereum Virtual Machine for Interactive Theorem Provers"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://github.com/ethereum/eth2.0-specs",target:"_blank",rel:"noopener noreferrer"}},[e._v("Ethereum 2.0 Specifications"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://www.cs.umd.edu/~aseem/solidetherplas.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Formal Verification of Smart Contracts"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://jellopaper.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("JelloPaper: Human Readable Semantics of EVM in K"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://www.ideals.illinois.edu/bitstream/handle/2142/97207/hildenbrandt-saxena-zhu-rodrigues-guth-daian-rosu-2017-tr.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("KEVM: A Complete Semantics of the Ethereum Virtual Machine."),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://eprint.iacr.org/2016/633.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Making Smart Contracts Smarter"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://arxiv.org/pdf/1806.01143.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Securify: Practical Security Analysis of Smart Contracts"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://docs.thundercore.com/thunder-whitepaper.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("The Thunder Protocol"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://ts.data61.csiro.au/publications/csiro_full_text//Amani_BBS_18.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Towards Verifying Ethereum Smart Contract Bytecode in Isabelle/HOL"),s("OutboundLink")],1),e._v("\n*"),s("a",{attrs:{href:"https://github.com/seed/eth-isabelle/tree/evm15",target:"_blank",rel:"noopener noreferrer"}},[e._v("A Lem formalization of EVM 1.5"),s("OutboundLink")],1)])]),e._v(" "),s("h2",{attrs:{id:"copyright"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),s("p",[e._v("Copyright and related rights waived via "),s("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),s("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=n.exports}}]);