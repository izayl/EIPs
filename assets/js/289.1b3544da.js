(window.webpackJsonp=window.webpackJsonp||[]).push([[289],{690:function(e,t,a){"use strict";a.r(t);var n=a(46),o=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"simple-summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[e._v("#")]),e._v(" Simple Summary")]),e._v(" "),a("p",[e._v("Account abstraction (AA) allows a contract to be the top-level account that pays fees and starts transaction execution.")]),e._v(" "),a("h2",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),a("p",[a("strong",[e._v("See also: "),a("a",{attrs:{href:"https://ethereum-magicians.org/t/implementing-account-abstraction-as-part-of-eth1-x/4020",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://ethereum-magicians.org/t/implementing-account-abstraction-as-part-of-eth1-x/4020"),a("OutboundLink")],1),e._v(" and the links therein for historical work and motivation.")])]),e._v(" "),a("p",[e._v("Transaction validity, as of Muir Glacier, is defined rigidly by the protocol: ECDSA signature, a simple nonce, and account balance. Account abstraction extends the validity conditions of transactions with the execution of arbitrary EVM bytecode (with some limits on what state may be accessed.) To signal validity, we propose a new EVM opcode "),a("code",[e._v("PAYGAS")]),e._v(", which also sets the gas price and gas limit the contract is willing to pay.")]),e._v(" "),a("p",[e._v("We split account abstraction into two tiers: "),a("strong",[e._v("single-tenant AA")]),e._v(", which is intended to support wallets or other use cases with few participants, and "),a("strong",[e._v("multi-tenant AA")]),e._v(", which is intended to support applications with many participants (eg. tornado.cash, Uniswap).")]),e._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),a("p",[e._v("The existing limitations preclude innovation in a number of important areas, particularly:")]),e._v(" "),a("ol",[a("li",[e._v("Smart contract wallets that use signature verification other than ECDSA (eg. Schnorr, BLS, post-quantum...)")]),e._v(" "),a("li",[e._v("Smart contract wallets that include features such as multisig verification or social recovery, reducing the highly prevalent risk of funds being lost or stolen")]),e._v(" "),a("li",[e._v("Privacy-preserving systems like "),a("a",{attrs:{href:"http://tornado.cash",target:"_blank",rel:"noopener noreferrer"}},[e._v("tornado.cash"),a("OutboundLink")],1)]),e._v(" "),a("li",[e._v("Attempts to improve gas efficiency of DeFi protocols by preventing transactions that don't satisfy high-level conditions (eg. existence of a matching order) from being included on chain")]),e._v(" "),a("li",[e._v("Users being able to pay for transaction fees in a token other than ETH (eg. by converting that token into the ETH needed for fees inside the transaction in real-time)")])]),e._v(" "),a("p",[e._v("Most of the above use cases are currently possible using intermediaries, most notably the "),a("a",{attrs:{href:"https://www.opengsn.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Gas Station Network"),a("OutboundLink")],1),e._v(" and application-specific alternatives. These implementations are (i) technically inefficient, due to the extra 21000 gas to pay for the relayer, (ii) economically inefficient, as relayers need to make a profit on top of the gas fees that they pay. Additionally, use of intermediary protocols means that these applications cannot simply rely on base Ethereum infrastructure and need to rely on extra protocols that have smaller userbases and higher risk of no longer being available at some future date.")]),e._v(" "),a("p",[e._v("Out of the five use cases above, single-tenant AA approximately supports (1) and (2), and multi-tenant AA approximately supports (3) and (4). We discuss the differences between the two tiers in the specification and rationale sections below.")]),e._v(" "),a("h2",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),a("h3",{attrs:{id:"single-tenant"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#single-tenant"}},[e._v("#")]),e._v(" Single Tenant")]),e._v(" "),a("p",[e._v("After "),a("code",[e._v("FORK_BLOCK")]),e._v(", the following changes will be recognized by the protocol.")]),e._v(" "),a("h4",{attrs:{id:"constants"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#constants"}},[e._v("#")]),e._v(" Constants")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Constant")]),e._v(" "),a("th",[e._v("Value")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[a("strong",[a("code",[e._v("AA_ENTRY_POINT")])])]),e._v(" "),a("td",[a("code",[e._v("0xffffffffffffffffffffffffffffffffffffffff")])])]),e._v(" "),a("tr",[a("td",[a("strong",[a("code",[e._v("AA_TX_TYPE")])])]),e._v(" "),a("td",[a("code",[e._v("2")])])]),e._v(" "),a("tr",[a("td",[a("strong",[a("code",[e._v("FORK_BLOCK")])])]),e._v(" "),a("td",[e._v("TBD")])]),e._v(" "),a("tr",[a("td",[a("strong",[a("code",[e._v("AA_BASE_GAS_COST")])])]),e._v(" "),a("td",[e._v("15000")])])])]),e._v(" "),a("h4",{attrs:{id:"new-transaction-type"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new-transaction-type"}},[e._v("#")]),e._v(" New Transaction Type")]),e._v(" "),a("p",[e._v("A new "),a("RouterLink",{attrs:{to:"/eip-2718.html"}},[e._v("EIP-2718")]),e._v(" transaction with type "),a("code",[e._v("AA_TX_TYPE")]),e._v(' is introduced. Transactions of this type are referred to as "AA transactions". Their payload should be interpreted as '),a("code",[e._v("rlp([nonce, target, data])")]),e._v(".")],1),e._v(" "),a("p",[e._v("The base gas cost of this transaction is set to "),a("code",[e._v("AA_BASE_GAS_COST")]),e._v(' instead of 21000 to reflect the lack of "intrinsic" ECDSA and signature.')]),e._v(" "),a("p",[e._v("Nonces are processed analogously to existing transactions (check "),a("code",[e._v("tx.nonce == tx.target.nonce")]),e._v(", transaction is invalid if this fails, otherwise proceed and immediately set "),a("code",[e._v("tx.nonce += 1")]),e._v(").")]),e._v(" "),a("p",[e._v("Note that this transaction type has no intrinsic gas limit; when beginning execution, the gas limit is simply set to the remaining gas in the block (ie. "),a("code",[e._v("block.gas_limit")]),e._v(" minus gas spent on previous transactions), and the "),a("code",[e._v("PAYGAS")]),e._v(" opcode (see below) can adjust the gas limit downwards.")]),e._v(" "),a("h4",{attrs:{id:"transaction-wide-global-variables"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transaction-wide-global-variables"}},[e._v("#")]),e._v(" Transaction-wide global variables")]),e._v(" "),a("p",[e._v("Introduce some new transaction-wide global variables. These variables work similarly (in particular, have similar reversion logic) to the SSTORE refunds counter.")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Variable")]),e._v(" "),a("th",[e._v("Type")]),e._v(" "),a("th",[e._v("Initial value")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[a("code",[e._v("globals.transaction_fee_paid")])]),e._v(" "),a("td",[a("code",[e._v("bool")])]),e._v(" "),a("td",[a("code",[e._v("False if type(tx) == AA_TX_TYPE else True")])])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("globals.gas_price")])]),e._v(" "),a("td",[a("code",[e._v("int")])]),e._v(" "),a("td",[a("code",[e._v("0 if type(tx) == AA_TX_TYPE else tx.gas_price")])])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("globals.gas_limit")])]),e._v(" "),a("td",[a("code",[e._v("int")])]),e._v(" "),a("td",[a("code",[e._v("0 if type(tx) == AA_TX_TYPE else tx.gas_limit")])])])])]),e._v(" "),a("h4",{attrs:{id:"nonce-0x48-opcode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nonce-0x48-opcode"}},[e._v("#")]),e._v(" "),a("code",[e._v("NONCE (0x48)")]),e._v(" Opcode")]),e._v(" "),a("p",[e._v("A new opcode "),a("code",[e._v("NONCE (0x48)")]),e._v(" is introduced, with gas cost "),a("code",[e._v("G_base")]),e._v(", which pushes the "),a("code",[e._v("nonce")]),e._v(" of the callee onto the stack.")]),e._v(" "),a("h4",{attrs:{id:"paygas-0x49-opcode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#paygas-0x49-opcode"}},[e._v("#")]),e._v(" "),a("code",[e._v("PAYGAS (0x49)")]),e._v(" Opcode")]),e._v(" "),a("p",[e._v("A new opcode "),a("code",[e._v("PAYGAS (0x49)")]),e._v(" is introduced, with gas cost "),a("code",[e._v("G_base")]),e._v(". It takes two arguments off the stack: (top) "),a("code",[e._v("version_number")]),e._v(", (second from top) "),a("code",[e._v("memory_start")]),e._v(". In the initial implementation, it will "),a("code",[e._v("assert version_number == 0")]),e._v(" and read:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("gas_price = bytes_to_int(vm.memory[memory_start: memory_start + 32])")])]),e._v(" "),a("li",[a("code",[e._v("gas_limit = bytes_to_int(vm.memory[memory_start + 32: memory_start + 64])")])])]),e._v(" "),a("p",[e._v("Both reads use similar mechanics to MLOAD and CALL, so memory expands if needed.")]),e._v(" "),a("p",[e._v("Future hard forks may add support for different version numbers, in which case the opcode may take different-sized memory slices and interpret them differently. Two particular potential use cases are "),a("a",{attrs:{href:"https://notes.ethereum.org/@vbuterin/BkSQmQTS8",target:"_blank",rel:"noopener noreferrer"}},[e._v("EIP 1559"),a("OutboundLink")],1),e._v(" and "),a("a",{attrs:{href:"https://ethresear.ch/t/another-simple-gas-fee-model-the-escalator-algorithm-from-the-agoric-papers/6399",target:"_blank",rel:"noopener noreferrer"}},[e._v("the escalator mechanism"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("p",[e._v("The opcode works as follows. If all three of the following conditions (in addition to the version number check above) are satisfied:")]),e._v(" "),a("ol",[a("li",[e._v("The account's balance is "),a("code",[e._v(">= gas_price * gas_limit")])]),e._v(" "),a("li",[a("code",[e._v("globals.transaction_fee_paid == False")])]),e._v(" "),a("li",[e._v("We are in a top-level AA execution frame (ie. if the currently running EVM execution exits or reverts, the EVM execution of the entire transaction is finished)")])]),e._v(" "),a("p",[e._v("Then do the following:")]),e._v(" "),a("ul",[a("li",[e._v("Subtract "),a("code",[e._v("gas_price * gas_limit")]),e._v(" from the contract's balance")]),e._v(" "),a("li",[e._v("Set "),a("code",[e._v("globals.transaction_fee_paid")]),e._v(" to "),a("code",[e._v("True")])]),e._v(" "),a("li",[e._v("Set "),a("code",[e._v("globals.gas_price")]),e._v(" to "),a("code",[e._v("gas_price")]),e._v(", and "),a("code",[e._v("globals.gas_limit")]),e._v(" to "),a("code",[e._v("gas_limit")])]),e._v(" "),a("li",[e._v("Set the remaining gas in the current execution context to equal "),a("code",[e._v("gas_limit")]),e._v(" minus the gas that was already consumed")])]),e._v(" "),a("p",[e._v("If any of the above three conditions are not satisfied, throw an exception.")]),e._v(" "),a("p",[e._v("At the end of execution of an AA transaction, it is mandatory that "),a("code",[e._v("globals.transaction_fee_paid == True")]),e._v("; if it is not, then the transaction is invalid. At the end of execution, the contract is refunded "),a("code",[e._v("globals.gas_price * remaining_gas")]),e._v(" for any remaining gas, and "),a("code",[e._v("(globals.gas_limit - remaining_gas) * globals.gas_price")]),e._v(" is transferred to the miner.")]),e._v(" "),a("p",[a("code",[e._v("PAYGAS")]),e._v(" also serves as an EVM execution "),a("em",[e._v("checkpoint")]),e._v(": if the top-level execution frame reverts after "),a("code",[e._v("PAYGAS")]),e._v(" has been called, then the execution only reverts up to the point right after "),a("code",[e._v("PAYGAS")]),e._v(" was called, and exits there. In that case, the contract receives no refund, and "),a("code",[e._v("globals.gas_limit * globals.gas_price")]),e._v(" is transferred to the miner.")]),e._v(" "),a("h4",{attrs:{id:"replay-protection"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#replay-protection"}},[e._v("#")]),e._v(" Replay Protection")]),e._v(" "),a("p",[e._v("One of the two following approaches must be implemented to safeguard against replay attacks.")]),e._v(" "),a("h5",{attrs:{id:"require-set-indestructible"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#require-set-indestructible"}},[e._v("#")]),e._v(" Require "),a("code",[e._v("SET_INDESTRUCTIBLE")])]),e._v(" "),a("p",[e._v("Require that contracts targeted by AA transactions begin with "),a("RouterLink",{attrs:{to:"/eip-2937.html"}},[e._v("EIP-2937")]),e._v("'s "),a("code",[e._v("SET_INDESTRUCTIBLE")]),e._v(" opcode. AA transactions targeting contracts that do not begin with "),a("code",[e._v("SET_INDESTRUCTIBLE")]),e._v(" are invalid, and cannot be included in blocks.")],1),e._v(" "),a("p",[a("code",[e._v("AA_PREFIX")]),e._v(" would need to be modified to include this opcode.")]),e._v(" "),a("h5",{attrs:{id:"preserve-nonce-on-selfdestruct"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#preserve-nonce-on-selfdestruct"}},[e._v("#")]),e._v(" Preserve Nonce on "),a("code",[e._v("SELFDESTRUCT")])]),e._v(" "),a("p",[e._v("The other option is to preserve contract nonces across "),a("code",[e._v("SELFDESTRUCT")]),e._v(" invocations, instead of setting the nonce to zero.")]),e._v(" "),a("h4",{attrs:{id:"miscellaneous"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#miscellaneous"}},[e._v("#")]),e._v(" Miscellaneous")]),e._v(" "),a("ul",[a("li",[e._v("If "),a("code",[e._v("CALLER (0x33)")]),e._v(" is invoked in the first frame of\nexecution of a call initiated by an AA transaction, then it must return "),a("code",[e._v("AA_ENTRY_POINT")]),e._v(".")]),e._v(" "),a("li",[e._v("If "),a("code",[e._v("ORIGIN (0x32)")]),e._v(" is invoked in any frame of execution of an AA\ntransaction it must return "),a("code",[e._v("AA_ENTRY_POINT")]),e._v(".")]),e._v(" "),a("li",[e._v("The "),a("code",[e._v("GASPRICE (0x3A)")]),e._v(" opcode now pushes the value "),a("code",[e._v("globals.gas_price")])])]),e._v(" "),a("p",[e._v("Note that the new definition of "),a("code",[e._v("GASPRICE")]),e._v(" does not lead to any changes in behavior in non-AA transactions, because "),a("code",[e._v("globals.gas_price")]),e._v(" is initialized to "),a("code",[e._v("tx.gas_price")]),e._v(" and cannot be changed as "),a("code",[e._v("PAYGAS")]),e._v(" cannot be called.")]),e._v(" "),a("h4",{attrs:{id:"mining-and-rebroadcasting-strategies"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mining-and-rebroadcasting-strategies"}},[e._v("#")]),e._v(" Mining and Rebroadcasting Strategies")]),e._v(" "),a("p",[e._v("Much of the complexity in account abstraction originates from the strategies used by miners and validating nodes to determine whether or not to accept and rebroadcast transactions. Miners need to determine if a transaction will actually pay the fee if they include it after only a small amount of processing to avoid "),a("a",{attrs:{href:"https://hackingdistributed.com/2016/06/28/ethereum-soft-fork-dos-vector/",target:"_blank",rel:"noopener noreferrer"}},[e._v("DoS attacks"),a("OutboundLink")],1),e._v(". Validating nodes need to perform an essentially identical verification to determine whether or not to rebroadcast the transaction.")]),e._v(" "),a("p",[e._v("By keeping the consensus changes minimal, this EIP allows for gradual introduction of AA mempool support by miners and validating nodes. Initial support would be focused on enabling simple, single-tenant use cases, while later steps would additionally allow for more complex, multi-tenant use cases. Earlier stages are deliberately more fully fleshed-out than later stages, as there is still more time before later stages need to be implemented.")]),e._v(" "),a("h5",{attrs:{id:"transactions-with-fixed-nonces"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transactions-with-fixed-nonces"}},[e._v("#")]),e._v(" Transactions with Fixed Nonces")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Constant")]),e._v(" "),a("th",[e._v("Value")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[a("code",[e._v("VERIFICATION_GAS_MULTIPLIER")])]),e._v(" "),a("td",[a("code",[e._v("6")])])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("VERIFICATION_GAS_CAP")])]),e._v(" "),a("td",[a("code",[e._v("= VERIFICATION_GAS_MULTIPLIER * AA_BASE_GAS_COST = 90000")])])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("AA_PREFIX")])]),e._v(" "),a("td",[a("code",[e._v("if(msg.sender != shr(-1, 12)) { LOG1(msg.sender, msg.value); return }")]),e._v("; compilation to EVM TBD")])])])]),e._v(" "),a("p",[e._v("When a node receives an AA transaction, they process it (i.e. attempt to execute it against the current chain head's post-state) to determine its validity, continuing to execute until one of several events happens:")]),e._v(" "),a("ul",[a("li",[e._v("If the code of the "),a("code",[e._v("target")]),e._v(" is NOT prefixed with "),a("code",[e._v("AA_PREFIX")]),e._v(", exit with failure")]),e._v(" "),a("li",[e._v("If the execution hits any of the following, exit with failure:\n"),a("ul",[a("li",[e._v("An environment opcode ("),a("code",[e._v("BLOCKHASH")]),e._v(", "),a("code",[e._v("COINBASE")]),e._v(", "),a("code",[e._v("TIMESTAMP")]),e._v(", "),a("code",[e._v("NUMBER")]),e._v(", "),a("code",[e._v("DIFFICULTY")]),e._v(", "),a("code",[e._v("GASLIMIT")]),e._v(")")]),e._v(" "),a("li",[a("code",[e._v("BALANCE")]),e._v(" (of any account, including the "),a("code",[e._v("target")]),e._v(" itself)")]),e._v(" "),a("li",[e._v("An external call/create that changes the "),a("code",[e._v("callee")]),e._v(" to anything but the "),a("code",[e._v("target")]),e._v(" or a precompile ("),a("code",[e._v("CALL")]),e._v(", "),a("code",[e._v("CALLCODE")]),e._v(", "),a("code",[e._v("STATICCALL")]),e._v(", "),a("code",[e._v("CREATE")]),e._v(", "),a("code",[e._v("CREATE2")]),e._v(").")]),e._v(" "),a("li",[e._v("An external state access that reads code ("),a("code",[e._v("EXTCODESIZE")]),e._v(", "),a("code",[e._v("EXTCODEHASH")]),e._v(", "),a("code",[e._v("EXTCODECOPY")]),e._v(", but also "),a("code",[e._v("CALLCODE")]),e._v(" and "),a("code",[e._v("DELEGATECALL")]),e._v("), unless the address of the code that is read is the "),a("code",[e._v("target")]),e._v(".")])])]),e._v(" "),a("li",[e._v("If the execution consumes more gas than "),a("code",[e._v("VERIFICATION_GAS_CAP")]),e._v(" (specified above), or more gas than is available in the block, exit with failure")]),e._v(" "),a("li",[e._v("If the execution reaches "),a("code",[e._v("PAYGAS")]),e._v(", then exit with success or failure depending on whether or not the balance is sufficient (e.g. "),a("code",[e._v("balance >= gas_price * gas_limit")]),e._v(").")])]),e._v(" "),a("p",[e._v("Nodes do not keep transactions with nonces higher than the current valid nonce in the mempool. If the mempool already contains a transaction with a currently valid nonce, another incoming transaction to the same contract and with the same nonce either replaces the existing one (if its gas price is sufficiently higher) or is dropped. Thus, the mempool keeps only at most one pending transaction per account.")]),e._v(" "),a("p",[e._v("While processing a new block, take note of which accounts were the "),a("code",[e._v("target")]),e._v(" of an AA transaction (each block currently has "),a("code",[e._v("12500000")]),e._v(" gas and an AA transaction costs "),a("code",[e._v(">= 15000")]),e._v(" so there would be at most "),a("code",[e._v("12500000 // 15000 = 833")]),e._v(" targeted accounts). Drop all pending transactions targeting those accounts. All other transactions remain in the mempool.")]),e._v(" "),a("h3",{attrs:{id:"single-tenant-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#single-tenant-2"}},[e._v("#")]),e._v(" Single Tenant+")]),e._v(" "),a("p",[e._v("If the "),a("a",{attrs:{href:"http://github.com/ethereum/EIPs/pull/2937",target:"_blank",rel:"noopener noreferrer"}},[e._v("indestructible contracts EIP"),a("OutboundLink")],1),e._v(" is added, Single Tenant AA can be adapted to allow for "),a("code",[e._v("DELEGATECALL")]),e._v(" during transaction verification: during execution of a new AA transaction, external state access that reads code ("),a("code",[e._v("EXTCODESIZE")]),e._v(", "),a("code",[e._v("EXTCODEHASH")]),e._v(", "),a("code",[e._v("EXTCODECOPY")]),e._v(", "),a("code",[e._v("CALLCODE")]),e._v(", "),a("code",[e._v("DELEGATECALL")]),e._v(") of any contract whose first byte is the "),a("code",[e._v("SET_INDESTRUCTIBLE")]),e._v(" opcode is no longer banned. However, calls to anything but the "),a("code",[e._v("target")]),e._v(" or a precompile that change the "),a("code",[e._v("callee")]),e._v(" (i.e., calls other than "),a("code",[e._v("CALLCODE")]),e._v(" and "),a("code",[e._v("DELEGATECALL")]),e._v(") are still not permitted.")]),e._v(" "),a("p",[e._v("If the "),a("a",{attrs:{href:"http://github.com/ethereum/EIPs/pull/2975",target:"_blank",rel:"noopener noreferrer"}},[e._v("IS_STATIC EIP"),a("OutboundLink")],1),e._v(" is added, the list of allowed prefixes can be extended to allow a prefix that enables incoming static calls but not state-changing calls.")]),e._v(" "),a("p",[e._v("The list of allowed prefixes can also be extended to enable other benign use cases (eg. logging incoming payments).")]),e._v(" "),a("p",[e._v("External calls "),a("em",[e._v("into")]),e._v(" AA accounts can be allowed as follows. We can add an opcode "),a("code",[e._v("RESERVE_GAS")]),e._v(", which takes as argument a value "),a("code",[e._v("N")]),e._v(" and has simple behavior: immediately burn "),a("code",[e._v("N")]),e._v(" gas and add "),a("code",[e._v("N")]),e._v(" gas to the refund. We then add an allowed "),a("code",[e._v("AA_PREFIX")]),e._v(" that reserves "),a("code",[e._v(">= AA_BASE_GAS_COST * 2")]),e._v(" gas. This ensures that at least "),a("code",[e._v("AA_BASE_GAS_COST")]),e._v(" gas must be spent (as refunds can refund max 50% of total consumption) in order to call into an account and invalidate transactions targeting that account in the mempool, preserving that invariant.")]),e._v(" "),a("p",[e._v("Note that accounts may also opt to set a higher "),a("code",[e._v("RESERVE_GAS")]),e._v(" value in order to safely have a higher "),a("code",[e._v("VERIFICATION_GAS_CAP")]),e._v("; the goal would be to preserve a "),a("code",[e._v("VERIFICATION_GAS_MULTIPLIER")]),e._v("-to-1 ratio between the minimum gas cost to edit an account (ie. half its "),a("code",[e._v("RESERVE_GAS")]),e._v(") and the "),a("code",[e._v("VERIFICATION_GAS_CAP")]),e._v(" that is permitted that account. This would also preserve invariants around maximum reverification gas consumption that are implied by the previous section.")]),e._v(" "),a("h3",{attrs:{id:"multi-tenant-beyond"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#multi-tenant-beyond"}},[e._v("#")]),e._v(" Multi-Tenant & Beyond")]),e._v(" "),a("p",[e._v("In a later stage, we can add support for multiple pending transactions per account in the mempool. The main challenge here is that a single transaction can potentially cause state changes that invalidate all other transactions to that same account. Additionally, if we naively prioritize transactions by gasprice, there is an attack vector where the user willing to pay the highest gasprice publishes many (mutually exclusive) versions of their transaction with small alterations, thereby pushing everyone else's transactions out of the mempool.")]),e._v(" "),a("p",[e._v("Here is a sketch of a strategy for mitigating this problem. We would require incoming transactions to contain an "),a("a",{attrs:{href:"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2930.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("EIP-2930"),a("OutboundLink")],1),e._v("-style access list detailing the storage slots that the transaction reads or modifies, and make it binding; that is, accesses outside the access list would be invalid. A transaction would only be included in the mempool if its access list is disjoint from the access lists of other transactions in the mempool (or if its gasprice is higher). An alternative way to think about this is to have per-storage-slot mempools instead of just per-account mempools, except a transaction could be part of multiple per-storage-slot mempools (if desired it could be capped to eg. 5 storage slots).")]),e._v(" "),a("p",[e._v("Note also that multi-tenant AA will almost certainly require allowing miners to edit the nonces of incoming transactions to put them into sequence, with the result that the final hash of a transaction is unpredictable at publication time. Clients will need to explicitly work around this.")]),e._v(" "),a("p",[e._v("More research is required to refine these ideas, and this is left for later work.")]),e._v(" "),a("h2",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),a("p",[e._v("The core problem in an account abstraction setup is always that miners and network nodes need to be able to verify that a transaction that they attempt to include, or rebroadcast, will actually pay a fee. Currently, this is fairly simple, because a transaction is guaranteed to be includable and pay a fee as long as the signature and nonce are valid and the balance and gasprice are sufficient. These checks can be done quickly.")]),e._v(" "),a("p",[e._v("In an account abstraction setup, the goal is to allow accounts to specify EVM code that can establish more flexible conditions for a transaction's validity, but with the requirement that this EVM code can be quickly verified, with the same safety properties as the existing setup.")]),e._v(" "),a("p",[e._v("In a normal transaction, the top-level call goes from the "),a("code",[e._v("tx.sender")]),e._v(" to "),a("code",[e._v("tx.to")]),e._v(" and carries with it "),a("code",[e._v("tx.value")]),e._v(". In an AA transaction, the top-level call goes from the "),a("em",[e._v("entry point address")]),e._v(" ("),a("code",[e._v("0xFFFF...FF")]),e._v(") to the "),a("code",[e._v("tx.target")]),e._v(".")]),e._v(" "),a("p",[e._v("The top-level code execution is expected to be split into two phases: the shorter "),a("strong",[e._v("verification phase")]),e._v(" (before "),a("code",[e._v("PAYGAS")]),e._v(") and the longer "),a("strong",[e._v("execution phase")]),e._v(" (after "),a("code",[e._v("PAYGAS")]),e._v("). If execution throws an exception during the verification phase, the transaction is invalid, much like a transaction with an invalid signature in the current system. If execution throws an exception after the verification phase, the transaction pays fees, and so the miner can still include it.")]),e._v(" "),a("p",[e._v("The transition between different stages of AA is entirely done through changes in miner strategy. The first stage supports "),a("strong",[e._v("single-tenant AA")]),e._v(", where the only use cases that can be easily implemented are where the "),a("code",[e._v("tx.target")]),e._v(" is a contract representing a user account (that is, a smart contract wallet, eg. multisig). Later stages improve support for eg. logs and libraries, and also move toward supporting "),a("strong",[e._v("multi-tenant AA")]),e._v(", where the goal is to try to support cases where the "),a("code",[e._v("tx.target")]),e._v(" represents an "),a("em",[e._v("application")]),e._v(" that processes incoming activity from multiple users.")]),e._v(" "),a("h3",{attrs:{id:"nonces-still-enshrined-in-single-tenant-aa"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nonces-still-enshrined-in-single-tenant-aa"}},[e._v("#")]),e._v(" Nonces still enshrined in single-tenant AA")]),e._v(" "),a("p",[e._v("Nonces are still enforced in single-tenant AA to ensure that single-target AA does not break the invariant that each transaction (and hence each transaction hash) can only be included in the chain once. While there is some limited value in allowing arbitrary-order transaction inclusion in single-tenant AA, there is not enough value to justify breaking that invariant.")]),e._v(" "),a("p",[e._v("Note that nonces in AA accounts do end up having a dual-purpose: they are both there for replay protection and for contract address generation when using the "),a("code",[e._v("CREATE")]),e._v(" opcode. This does mean that a single transaction could increment the nonce by more than 1. This is deemed acceptable, as the other mechanics introduced by AA already break the ability to easily verify that a chain longer than one transaction can be processed. However, we strongly recommend that AA contracts use "),a("code",[e._v("CREATE2")]),e._v(" instead of "),a("code",[e._v("CREATE")]),e._v(".")]),e._v(" "),a("p",[e._v("In multi-tenant AA, as mentioned above, nonces are expected to become malleable and applications that use multi-tenant AA systems would need to manage this.")]),e._v(" "),a("h3",{attrs:{id:"nonces-are-exposed-to-the-evm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nonces-are-exposed-to-the-evm"}},[e._v("#")]),e._v(" Nonces are exposed to the EVM")]),e._v(" "),a("p",[e._v("This is done to allow signature checking done in validation code to validate the nonce.")]),e._v(" "),a("h3",{attrs:{id:"replay-protection-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#replay-protection-2"}},[e._v("#")]),e._v(" Replay Protection")]),e._v(" "),a("p",[e._v("One of the above two approaches (requiring "),a("code",[e._v("SET_INDESTRUCTIBLE")]),e._v(" or modifying "),a("code",[e._v("SELFDESTRUCT")]),e._v(" behavior) must be implemented so that nonces cannot be reused. It must be a consensus change, and not simply part of "),a("code",[e._v("AA_PREFIX")]),e._v(", so that transaction hash uniqueness is maintained.")]),e._v(" "),a("h3",{attrs:{id:"miners-refuse-transactions-that-access-external-data-or-the-target-s-own-balance-before-paygas"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#miners-refuse-transactions-that-access-external-data-or-the-target-s-own-balance-before-paygas"}},[e._v("#")]),e._v(" Miners refuse transactions that access external data or the target's own balance, before PAYGAS")]),e._v(" "),a("p",[e._v("An important property of traditional transactions is that activity happening as part of transactions that originate outside of some given account X cannot make transactions whose sender is X invalid. The only state change that an outside transaction can impose on X is increasing its balance, which cannot invalidate a transaction.")]),e._v(" "),a("p",[e._v("Allowing AA contracts to access external data (both other accounts and environment variables such as GASPRICE, DIFFICULTY, etc.) before they call "),a("code",[e._v("PAYGAS")]),e._v(" (ie. during the verification phase) breaks this invariant. For example, imagine someone sends many thousands of AA transactions that perform an external call "),a("code",[e._v("if FOO.get_number() != 5: throw()")]),e._v(". "),a("code",[e._v("FOO.number")]),e._v(" might be set to "),a("code",[e._v("5")]),e._v(" when those transactions are all sent, but a single transaction to "),a("code",[e._v("FOO")]),e._v(" could set the "),a("code",[e._v("number")]),e._v(" to something else, invalidating "),a("em",[e._v("all of the thousands of AA transactions")]),e._v(" that depend on it. This would be a serious DoS vector.")]),e._v(" "),a("p",[e._v("The one allowed exception is contracts that are indestructible (that is, whose first byte is the "),a("code",[e._v("SET_INDESTRUCTIBLE")]),e._v(" opcode defined in "),a("a",{attrs:{href:"https://hackmd.io/@HWeNw8hNRimMm2m2GH56Cw/SyNT3Cdmw",target:"_blank",rel:"noopener noreferrer"}},[e._v("this EIP"),a("OutboundLink")],1),e._v("). This is a safe exception, because the data that is being read cannot be changed.")]),e._v(" "),a("p",[e._v("Disallowing reading "),a("code",[e._v("BALANCE")]),e._v(" blocks a milder attack vector: an attacker could force a transaction to be reprocessed at a mere cost of 6700 gas (not 15000 or 21000), in the worst case more than doubling the number of transactions that would need to be reprocessed.")]),e._v(" "),a("p",[e._v("In the long term, AA could be expanded to allow reading external data, though protections such as mandatory access lists would be required.")]),e._v(" "),a("h3",{attrs:{id:"aa-transactions-must-call-contracts-with-prefix"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aa-transactions-must-call-contracts-with-prefix"}},[e._v("#")]),e._v(" AA transactions must call contracts with prefix")]),e._v(" "),a("p",[e._v("The prelude is used to ensure that "),a("em",[e._v("only")]),e._v(" AA transactions can call the contract. This is another measure taken to ensure the invariant described above. If this check did not occur, it would be possible for a transaction originating outside some AA account X to call into X and make a storage change, forcing transactions targeting that account to be reprocessed at the cost of a mere 5000 gas.")]),e._v(" "),a("h3",{attrs:{id:"multi-tenant-aa"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#multi-tenant-aa"}},[e._v("#")]),e._v(" Multi-tenant AA")]),e._v(" "),a("p",[e._v("Multi-tenant AA extends single-tenant AA by "),a("strong",[e._v("better handling cases where distinct and uncoordinated users attempt to send transactions for/to the same account and those transactions may interfere with each other")]),e._v(".")]),e._v(" "),a("p",[e._v("We can understand the value of multi-tenant AA by examining two example use cases: (i) "),a("a",{attrs:{href:"http://tornado.cash",target:"_blank",rel:"noopener noreferrer"}},[e._v("tornado.cash"),a("OutboundLink")],1),e._v(" and (ii) "),a("a",{attrs:{href:"http://uniswap.exchange",target:"_blank",rel:"noopener noreferrer"}},[e._v("Uniswap"),a("OutboundLink")],1),e._v(". In both of these cases, there is a single central contract that represents the application, and not any specific user. Nevertheless, there is important value in using abstraction to do application-specific validation of transactions.")]),e._v(" "),a("h4",{attrs:{id:"tornado-cash"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tornado-cash"}},[e._v("#")]),e._v(" Tornado Cash")]),e._v(" "),a("p",[e._v("The tornado.cash workflow is as follows:")]),e._v(" "),a("ol",[a("li",[e._v("A user sends a transaction to the TC contract, depositing some standard quantity of coins (eg. 1 ETH). A record of their deposit, containing the hash of a secret known by the user, is added to a Merkle tree whose root is stored in the TC contract.")]),e._v(" "),a("li",[e._v("When that user later wants to withdraw, they generate and send a ZK-SNARK proving that they know a secret whose hash is in a leaf somewhere in the deposit tree (without revealing where). The TC contract verifies the ZK-SNARK, and also verifies that a nullifier value (also derivable from the secret) has not yet been spent. The contract sends 1 ETH to the user's desired address, and saves a record that the user's nullifier has been spent.")])]),e._v(" "),a("p",[e._v("The privacy provided by TC arises because when a user makes a withdrawal, they can prove that it came from "),a("em",[e._v("some")]),e._v(" unique deposit, but no one other than the user knows which deposit it came from. However, implementing TC naively has a fatal flaw: the user usually does not yet have ETH in their withdrawal address, and if the user uses their deposit address to pay for gas, that creates an on-chain link between their deposit address and their withdrawal address.")]),e._v(" "),a("p",[e._v("Currently, this is solved via relayers; a third-party relayer verifies the ZK-SNARK and unspent status of the nullifier, publishes the transaction using their own ETH to pay for gas, and collects the fee back from the user from the TC contract.")]),e._v(" "),a("p",[e._v("AA allows this without relayers: the user could simply send an AA transaction targeting the TC contract, the ZK-SNARK verification and the nullifier checking can be done in the verification step, and PAYGAS can be called directly after that. This allows the withdrawer to pay for gas directly out of the coins going to their withdrawal address, avoiding the need for relayers or for an on-chain link to their deposit address.")]),e._v(" "),a("p",[e._v("Note that fully implementing this functionality requires AA to be structured in a way that supports multiple users sending withdrawals at the same time (requiring nonces would make this difficult), and that allows a single account to support both AA transactions (the withdrawals) and externally-initiated calls (the deposits).")]),e._v(" "),a("h4",{attrs:{id:"uniswap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#uniswap"}},[e._v("#")]),e._v(" Uniswap")]),e._v(" "),a("p",[e._v("A new version of Uniswap could be built that allows transactions to be sent that directly target the Uniswap contract. Users could deposit tokens into Uniswap ahead of time, and Uniswap would store their balances as well as a public key that transactions spending those balances could be verified against. An AA-initiated Uniswap trade would only be able to spend these internal balances.")]),e._v(" "),a("p",[e._v('This would be useless for normal traders, as normal traders have their coins outside the Uniswap contract, but it would be a powerful boon to arbitrageurs. Arbitrageurs would deposit their coins into Uniswap, and they would be able to send transactions that perform arbitrage every time external market conditions change, and logic such as price limits could be enforced during the verification step. Hence, transactions that do not get in (eg. because some other arbitrageur made the trade first) would not be included on-chain, allowing arbitrageurs to not pay gas, and reducing the number of "junk" transactions that get included on-chain. This could significantly increase both de-facto blockchain scalability as well as market efficiency, as arbitrageurs would be able to much more finely correct for cross-exchange discrepancies between prices.')]),e._v(" "),a("p",[e._v("Note that here also, Uniswap would need to support both AA transactions and externally-initiated calls.")]),e._v(" "),a("h2",{attrs:{id:"backwards-compatibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),a("p",[e._v("This AA implementation preserves the existing transaction type. The use of "),a("code",[e._v("assert origin == caller")]),e._v(" to verify that an account is an EOA remains sound, but is not extensible to AA accounts; AA transactions will always have "),a("code",[e._v("origin == AA_ENTRY_POINT")]),e._v(".")]),e._v(" "),a("p",[e._v("Badly-designed single-tenant AA contracts will break the transaction non-malleability invariant. That is, it is possible to take an AA transaction in-flight, modify it, and have the modified version still be valid; AA account contracts can be designed in such a way as to make that not possible, but it is their responsibility. Multi-tenant AA will break the transaction non-malleability invariant much more thoroughly, making the transaction hash unpredictable even for legitimate applications that use the multi-tenant AA features (though the invariant will not further break for applications that existed before then).")]),e._v(" "),a("p",[e._v("AA contracts may not have replay protection unless they build it in explicitly; this can be done with the "),a("code",[e._v("CHAINID (0x46)")]),e._v(" opcode introduced in "),a("RouterLink",{attrs:{to:"/eip-1344.html"}},[e._v("EIP 1344")]),e._v(".")],1),e._v(" "),a("h2",{attrs:{id:"test-cases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test-cases"}},[e._v("#")]),e._v(" Test Cases")]),e._v(" "),a("p",[e._v("See: "),a("a",{attrs:{href:"https://github.com/quilt/tests/tree/account-abstraction",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/quilt/tests/tree/account-abstraction"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),a("p",[e._v("See: "),a("a",{attrs:{href:"https://github.com/quilt/go-ethereum/tree/account-abstraction",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/quilt/go-ethereum/tree/account-abstraction"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"security-considerations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#security-considerations"}},[e._v("#")]),e._v(" Security Considerations")]),e._v(" "),a("p",[e._v("See "),a("a",{attrs:{href:"https://ethresear.ch/t/dos-vectors-in-account-abstraction-aa-or-validation-generalization-a-case-study-in-geth/7937",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://ethresear.ch/t/dos-vectors-in-account-abstraction-aa-or-validation-generalization-a-case-study-in-geth/7937"),a("OutboundLink")],1),e._v(" for an analysis of DoS issues.")]),e._v(" "),a("h3",{attrs:{id:"re-validation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#re-validation"}},[e._v("#")]),e._v(" Re-validation")]),e._v(" "),a("p",[e._v("When a transaction enters the mempool, the client is able to quickly ascertain whether the transaction is valid. Once it determines this, it can be confident that the transaction will continue to be valid unless a transaction from the same account invalidates it.")]),e._v(" "),a("p",[e._v("There are, however, cases where an attacker can publish a transaction that invalidates existing transactions and requires the network to perform more recomputation than the computation in the transaction itself. The EIP maintains the invariant that recomputation is bounded to a theoretical maximum of six times the block gas limit in a single block; this is somewhat more expensive than before, but not that much more expensive.")]),e._v(" "),a("h4",{attrs:{id:"peer-denial-of-service"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#peer-denial-of-service"}},[e._v("#")]),e._v(" Peer denial-of-service")]),e._v(" "),a("p",[e._v("Denial-of-Service attacks are difficult to defend against, due to the difficulty in identifying sybils within a peer list. At any moment, one may decide (or be bribed) to initiate an attack. This is not a problem that Account Abstraction introduces. It can be accomplished against existing clients today by inundating a target with transactions whose signatures are invalid. However, due to the increased allotment of validation work allowed by AA, it's important to bound the amount of computation an adversary can force a client to expend with invalid transactions. For this reason, it's best for the miner to follow the recommended mining strategies.")]),e._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),a("p",[e._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),a("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=o.exports}}]);