(window.webpackJsonp=window.webpackJsonp||[]).push([[180],{576:function(e,t,a){"use strict";a.r(t);var i=a(46),o=Object(i.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"simple-summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[e._v("#")]),e._v(" Simple Summary")]),e._v(" "),a("p",[e._v("Precompiled contracts for elliptic curve pairing operations are required in order to perform zkSNARK verification within the block gas limit.")]),e._v(" "),a("h2",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),a("p",[e._v("This EIP suggests to add precompiled contracts for a pairing function on a specific pairing-friendly elliptic curve. This can in turn be combined with "),a("RouterLink",{attrs:{to:"/eip-196.html"}},[e._v("EIP-196")]),e._v(" to verify zkSNARKs in Ethereum smart contracts. The general benefit of zkSNARKs for Ethereum is that it will increase the privacy for users (because of the Zero-Knowledge property) and might also be a scalability solution (because of the succinctness and efficient verifiability property).")],1),e._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),a("p",[e._v("Current smart contract executions on Ethereum are fully transparent, which makes them unsuitable for several use-cases that involve private information like the location, identity or history of past transactions. The technology of zkSNARKs could be a solution to this problem. While the Ethereum Virtual Machine can make use of zkSNARKs in theory, they are currently too expensive\nto fit the block gas limit. Because of that, this EIP proposes to specify certain parameters for some elementary primitives that enable zkSNARKs so that they can be implemented more efficiently and the gas cost be reduced.")]),e._v(" "),a("p",[e._v("Note that fixing these parameters will in no way limit the use-cases for zkSNARKs, it will even allow for incorporating some advances in zkSNARK research without the need for a further hard fork.")]),e._v(" "),a("p",[e._v("Pairing functions can be used to perform a limited form of multiplicatively homomorphic operations, which are necessary for current zkSNARKs. This precompile can be used to run such computations within the block gas limit. This precompiled contract only specifies a certain check, and not an evaluation of a pairing function. The reason is that the codomain of a pairing function is a rather complex field which could provide encoding problems and all known uses of pairing function in zkSNARKs only require the specified check.")]),e._v(" "),a("h2",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),a("p",[e._v("For blocks where "),a("code",[e._v("block.number >= BYZANTIUM_FORK_BLKNUM")]),e._v(', add a precompiled contracts for a bilinear function on groups on the elliptic curve "alt_bn128". We will define the precompiled contract in terms of a discrete logarithm. The discrete logarithm is of course assumed to be hard to compute, but we will give an equivalent specification that makes use of elliptic curve pairing functions which can be efficiently computed below.')]),e._v(" "),a("p",[e._v("Address: 0x8")]),e._v(" "),a("p",[e._v("For a cyclic group "),a("code",[e._v("G")]),e._v(" (written additively) of prime order "),a("code",[e._v("q")]),e._v(" let "),a("code",[e._v("log_P: G -> F_q")]),e._v(" be the discrete logarithm on this group with respect to a generator "),a("code",[e._v("P")]),e._v(", i.e. "),a("code",[e._v("log_P(x)")]),e._v(" is the smallest non-negative integer "),a("code",[e._v("n")]),e._v(" such that "),a("code",[e._v("n * P = x")]),e._v(".")]),e._v(" "),a("p",[e._v("The precompiled contract is defined as follows, where the two groups "),a("code",[e._v("G_1")]),e._v(" and "),a("code",[e._v("G_2")]),e._v(" are defined by their generators "),a("code",[e._v("P_1")]),e._v(" and "),a("code",[e._v("P_2")]),e._v(" below. Both generators have the same prime order "),a("code",[e._v("q")]),e._v(".")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Input: (a1, b1, a2, b2, ..., ak, bk) from (G_1 x G_2)^k\nOutput: If the length of the input is incorrect or any of the inputs are not elements of\n        the respective group or are not encoded correctly, the call fails.\n        Otherwise, return one if\n        log_P1(a1) * log_P2(b1) + ... + log_P1(ak) * log_P2(bk) = 0\n        (in F_q) and zero else.\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])]),a("p",[e._v("Note that "),a("code",[e._v("k")]),e._v(" is determined from the length of the input. Following the section on the encoding below,\n"),a("code",[e._v("k")]),e._v(" is the length of the input divided by "),a("code",[e._v("192")]),e._v(". If the input length is not a multiple of "),a("code",[e._v("192")]),e._v(",\nthe call fails. Empty input is valid and results in returning one.")]),e._v(" "),a("p",[e._v("In order to check that an input is an element of "),a("code",[e._v("G_1")]),e._v(", verifying the encoding of the coordinates and checking that they satisfy the curve equation (or is the encoding of infinity) is sufficient. For "),a("code",[e._v("G_2")]),e._v(", in addition to that, the order of the element has to be checked to be equal to the group order "),a("code",[e._v("q = 21888242871839275222246405745257275088548364400416034343698204186575808495617")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"definition-of-the-groups"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#definition-of-the-groups"}},[e._v("#")]),e._v(" Definition of the groups")]),e._v(" "),a("p",[e._v("The groups "),a("code",[e._v("G_1")]),e._v(" and "),a("code",[e._v("G_2")]),e._v(" are cyclic groups of prime order "),a("code",[e._v("q = 21888242871839275222246405745257275088548364400416034343698204186575808495617")]),e._v(".")]),e._v(" "),a("p",[e._v("The group "),a("code",[e._v("G_1")]),e._v(" is defined on the curve "),a("code",[e._v("Y^2 = X^3 + 3")]),e._v(" over the field "),a("code",[e._v("F_p")]),e._v(" with "),a("code",[e._v("p = 21888242871839275222246405745257275088696311157297823662689037894645226208583")]),e._v(" with generator "),a("code",[e._v("P1 = (1, 2)")]),e._v(".")]),e._v(" "),a("p",[e._v("The group "),a("code",[e._v("G_2")]),e._v(" is defined on the curve "),a("code",[e._v("Y^2 = X^3 + 3/(i+9)")]),e._v(" over a different field "),a("code",[e._v("F_p^2 = F_p[i] / (i^2 + 1)")]),e._v(" (p is the same as above) with generator")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("P2 = (\n  11559732032986387107991004021392285783925812861821192530917403151452391805634 * i +\n  10857046999023057135944570762232829481370756359578518086990519993285655852781,\n  4082367875863433681332203403145435568316851327593401208105741076214120093531 * i +\n  8495653923123431417604973247489272438418190587263600148770280649306958101930\n)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])]),a("p",[e._v("Note that "),a("code",[e._v("G_2")]),e._v(" is the only group of order "),a("code",[e._v("q")]),e._v(" of that elliptic curve over the field "),a("code",[e._v("F_p^2")]),e._v(". Any other generator of order "),a("code",[e._v("q")]),e._v(" instead of "),a("code",[e._v("P2")]),e._v(" would define the same "),a("code",[e._v("G_2")]),e._v(". However, the concrete value of "),a("code",[e._v("P2")]),e._v(" is useful for skeptical readers who doubt the existence of a group of order "),a("code",[e._v("q")]),e._v(". They can be instructed to compare the concrete values of "),a("code",[e._v("q * P2")]),e._v(" and "),a("code",[e._v("P2")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"encoding"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#encoding"}},[e._v("#")]),e._v(" Encoding")]),e._v(" "),a("p",[e._v("Elements of "),a("code",[e._v("F_p")]),e._v(" are encoded as 32 byte big-endian numbers. An encoding value of "),a("code",[e._v("p")]),e._v(" or larger is invalid.")]),e._v(" "),a("p",[e._v("Elements "),a("code",[e._v("a * i + b")]),e._v(" of "),a("code",[e._v("F_p^2")]),e._v(" are encoded as two elements of "),a("code",[e._v("F_p")]),e._v(", "),a("code",[e._v("(a, b)")]),e._v(".")]),e._v(" "),a("p",[e._v("Elliptic curve points are encoded as a Jacobian pair "),a("code",[e._v("(X, Y)")]),e._v(" where the point at infinity is encoded as "),a("code",[e._v("(0, 0)")]),e._v(".")]),e._v(" "),a("p",[e._v("Note that the number "),a("code",[e._v("k")]),e._v(" is derived from the input length.")]),e._v(" "),a("p",[e._v("The length of the returned data is always exactly 32 bytes and encoded as a 32 byte big-endian number.")]),e._v(" "),a("h3",{attrs:{id:"gas-costs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gas-costs"}},[e._v("#")]),e._v(" Gas costs")]),e._v(" "),a("p",[e._v("The gas costs of the precompiled contract are "),a("code",[e._v("80 000 * k + 100 000")]),e._v(", where "),a("code",[e._v("k")]),e._v(" is the number of\npoints or, equivalently, the length of the input divided by 192.")]),e._v(" "),a("h2",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),a("p",[e._v("The specific curve "),a("code",[e._v("alt_bn128")]),e._v(" was chosen because it is particularly well-suited for zkSNARKs, or, more specifically their verification building block of pairing functions. Furthermore, by choosing this curve, we can use synergy effects with ZCash and re-use some of their components and artifacts.")]),e._v(" "),a("p",[e._v("The feature of adding curve and field parameters to the inputs was considered but ultimately rejected since it complicates the specification; the gas costs are much harder to determine and it would be possible to call the contracts on something which is not an actual elliptic curve or does not admit an efficient pairing implementation.")]),e._v(" "),a("p",[e._v("A non-compact point encoding was chosen since it still allows to perform some operations in the smart contract itself (inclusion of the full y coordinate) and two encoded points can be compared for equality (no third projective coordinate).")]),e._v(" "),a("p",[e._v("The encoding of field elements in "),a("code",[e._v("F_p^2")]),e._v(" was chosen in this order to be in line with the big endian encoding of the elements themselves.")]),e._v(" "),a("h2",{attrs:{id:"backwards-compatibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),a("p",[e._v('As with the introduction of any precompiled contract, contracts that already use the given addresses will change their semantics. Because of that, the addresses are taken from the "reserved range" below 256.')]),e._v(" "),a("h2",{attrs:{id:"test-cases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test-cases"}},[e._v("#")]),e._v(" Test Cases")]),e._v(" "),a("p",[e._v("To be written.")]),e._v(" "),a("h2",{attrs:{id:"implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),a("p",[e._v("The precompiled contract can be implemented using elliptic curve pairing functions, more specifically, an optimal ate pairing on the alt_bn128 curve, which can be implemented efficiently. In order to see that, first note that a pairing function "),a("code",[e._v("e: G_1 x G_2 -> G_T")]),e._v(" fulfills the following properties ("),a("code",[e._v("G_1")]),e._v(" and "),a("code",[e._v("G_2")]),e._v(" are written additively, "),a("code",[e._v("G_T")]),e._v(" is written multiplicatively):")]),e._v(" "),a("p",[e._v("(1) "),a("code",[e._v("e(m * P1, n * P2) = e(P1, P2)^(m * n)")]),e._v("\n(2) "),a("code",[e._v("e")]),e._v(" is non-degenerate")]),e._v(" "),a("p",[e._v("Now observe that")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("log_P1(a1) * log_P2(b1) + ... + log_P1(ak) * log_P2(bk) = 0 (in F_q)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("if and only if")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("e(P1, P2)^(log_P1(a1) * log_P2(b1) + ... + log_P1(ak) * log_P2(bk)) = 1 (in G_T)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("Furthermore, the left hand side of this equation is equal to")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("e(log_P1(a1) * P1, log_P2(b1) * P2) * ... * e(log_P1(ak) * P1, log_P2(bk) * P2)\n= e(a1, b1) * ... * e(ak, bk)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("And thus, the precompiled contract can be implemented by verifying that\n"),a("code",[e._v("e(a1, b1) * ... * e(ak, bk) = 1")])]),e._v(" "),a("p",[e._v("Implementations are available here:")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://github.com/scipr-lab/libff/blob/master/libff/algebra/curves/alt_bn128/alt_bn128_g1.hpp",target:"_blank",rel:"noopener noreferrer"}},[e._v("libff"),a("OutboundLink")],1),e._v(" (C++)")]),e._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/zcash/bn/blob/master/src/groups/mod.rs",target:"_blank",rel:"noopener noreferrer"}},[e._v("bn"),a("OutboundLink")],1),e._v(" (Rust)")]),e._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/ethereum/py_pairing/blob/master/py_ecc/bn128/bn128_pairing.py",target:"_blank",rel:"noopener noreferrer"}},[e._v("Python"),a("OutboundLink")],1)])]),e._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),a("p",[e._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),a("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=o.exports}}]);