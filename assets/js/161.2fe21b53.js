(window.webpackJsonp=window.webpackJsonp||[]).push([[161],{553:function(e,t,a){"use strict";a.r(t);var r=a(46),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"precompile-for-elliptic-curve-linear-combinations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#precompile-for-elliptic-curve-linear-combinations"}},[e._v("#")]),e._v(" Precompile for Elliptic Curve Linear Combinations")]),e._v(" "),a("h2",{attrs:{id:"simple-summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[e._v("#")]),e._v(" Simple Summary")]),e._v(" "),a("p",[e._v("Currently the EVM only supports "),a("em",[e._v("secp256k1")]),e._v(" in a limited way through "),a("code",[e._v("ecrecover")]),e._v(" and "),a("em",[e._v("altbn128")]),e._v(" through two pre-compiles. There are draft proposals to add more curves. There are many more elliptic curve that have useful application for integration with existing systems or newly developed curves for zero-knowledge proofs.")]),e._v(" "),a("p",[e._v("This EIP adds a precompile that allows whole classes of curves to be used.")]),e._v(" "),a("h2",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),a("p",[e._v("A precompile that takes a curve and computes a linear combination of curve points.")]),e._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),a("h2",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),a("p",[e._v("Given integers "),a("code",[e._v("m, α")]),e._v(" and "),a("code",[e._v("β")]),e._v(", scalars "),a("code",[e._v("s_i")]),e._v(", and curve points "),a("code",[e._v("A_i")]),e._v(" construct the elliptic curve")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("y² = x³ + α ⋅ x + β  mod  m\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("and compute the following")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("C = s₀ ⋅ A₀ + s₁ ⋅ A₁ + ⋯ + s_n ⋅ A_n\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("aka "),a("em",[e._v("linear combination")]),e._v(", "),a("em",[e._v("inner product")]),e._v(", "),a("em",[e._v("multi-multiplication")]),e._v(" or even "),a("em",[e._v("multi-exponentiation")]),e._v(".")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("(Cx, Cy) := ecmul(m, α, β,  s0, Ax0, As0, s1, Ax1, As1, ...)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("h3",{attrs:{id:"gas-cost"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gas-cost"}},[e._v("#")]),e._v(" Gas cost")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("BASE_GAS = ...\nADD_GAS  = ...\nMUL_GAS  = ...\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("The total gas cost is "),a("code",[e._v("BASE_GAS")]),e._v(" plus "),a("code",[e._v("ADD_GAS")]),e._v(" for each "),a("code",[e._v("s_i")]),e._v(" that is "),a("code",[e._v("1")]),e._v(" and "),a("code",[e._v("MUL_GAS")]),e._v(" for each "),a("code",[e._v("s_i > 1")]),e._v(" ("),a("code",[e._v("s_i = 0")]),e._v(" is free).")]),e._v(" "),a("h3",{attrs:{id:"encoding-of-points"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#encoding-of-points"}},[e._v("#")]),e._v(" Encoding of points")]),e._v(" "),a("p",[e._v("Encode as "),a("code",[e._v("(x, y')")]),e._v(" where "),a("code",[e._v("s")]),e._v(" indicates whether "),a("code",[e._v("y")]),e._v(" or "),a("code",[e._v("-y")]),e._v(" is to be taken. It follows SEC 1 v 1.9 2.3.4, except uncompressed points ("),a("code",[e._v("y' = 0x04")]),e._v(") are not supported.")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[a("code",[e._v("y'")])]),e._v(" "),a("th",[a("code",[e._v("(x, y)")])])])]),e._v(" "),a("tbody",[a("tr",[a("td",[a("code",[e._v("0x00")])]),e._v(" "),a("td",[e._v("Point at infinity")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("0x02")])]),e._v(" "),a("td",[e._v("Solution with "),a("code",[e._v("y")]),e._v(" even")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("0x03")])]),e._v(" "),a("td",[e._v("Solution with "),a("code",[e._v("y")]),e._v(" odd")])])])]),e._v(" "),a("p",[e._v("Conversion from affine coordinates to compressed coordinates is trivial: "),a("code",[e._v("y' = 0x02 | (y & 0x01)")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"special-cases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#special-cases"}},[e._v("#")]),e._v(" Special cases")]),e._v(" "),a("p",[a("strong",[e._v("Coordinate recovery.")]),e._v(" Set "),a("code",[e._v("s₀ = 1")]),e._v(". The output will be the recovered coordinates of "),a("code",[e._v("A₀")]),e._v(".")]),e._v(" "),a("p",[a("strong",[e._v("On-curve checking.")]),e._v(" Do coordinate recovery and compare "),a("code",[e._v("y")]),e._v(" coordinate.")]),e._v(" "),a("p",[a("strong",[e._v("Addition.")]),e._v(" Set "),a("code",[e._v("s₀ = s₁ = 1")]),e._v(", the output will be "),a("code",[e._v("A₀ + A₁")]),e._v(".")]),e._v(" "),a("p",[a("strong",[e._v("Doubling.")]),e._v(" Set "),a("code",[e._v("s₀ = 2")]),e._v(". The output will be "),a("code",[e._v("2 ⋅ A₀")]),e._v(". (Note: under current gas model this may be more costly than self-addition!)")]),e._v(" "),a("p",[a("strong",[e._v("Scalar multiplication.")]),e._v(" Set only "),a("code",[e._v("s₀")]),e._v(" and "),a("code",[e._v("A₀")]),e._v(".")]),e._v(" "),a("p",[a("strong",[e._v("Modular square root.")]),e._v(" Set "),a("code",[e._v("α = s₀ = A = 0")]),e._v(" the output will have "),a("code",[e._v("Cy² = β mod m")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"edge-cases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#edge-cases"}},[e._v("#")]),e._v(" Edge cases")]),e._v(" "),a("ul",[a("li",[e._v("Non-prime moduli or too small modulus")]),e._v(" "),a("li",[e._v("Field elements larger than modulus")]),e._v(" "),a("li",[e._v("Curve has singular points ("),a("code",[e._v("4 α³ + 27 β² = 0")]),e._v(")")]),e._v(" "),a("li",[e._v("Invalid sign bytes")]),e._v(" "),a("li",[e._v("x coordinate not on curve")]),e._v(" "),a("li",[e._v("Returning the point at infinity")]),e._v(" "),a("li",[e._v("(Please add if you spot more)")])]),e._v(" "),a("h2",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),a("p",[a("strong",[e._v("Generic Field and Curve.")]),e._v(" Many important optimizations are independent of the field and curve used. Some missed specific optimizations are:")]),e._v(" "),a("ul",[a("li",[e._v("Reductions specific to the binary structure of the field prime.")]),e._v(" "),a("li",[e._v("Precomputation of Montgomery factors.")]),e._v(" "),a("li",[e._v("Precomputation of multiples of certain popular points like the generator.")]),e._v(" "),a("li",[e._v("Special point addition/doubling "),a("a",{attrs:{href:"https://www.hyperelliptic.org/EFD/g1p/auto-shortw.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("formulas"),a("OutboundLink")],1),e._v(" for "),a("code",[e._v("α = -3")]),e._v(", "),a("code",[e._v("α = -1")]),e._v(", "),a("code",[e._v("α = 0")]),e._v(", "),a("code",[e._v("β = 0")]),e._v(".")])]),e._v(" "),a("p",[e._v("TODO: The special cases for "),a("code",[e._v("α")]),e._v(" and "),a("code",[e._v("β")]),e._v(" might be worth implementing and offered a gas discount.")]),e._v(" "),a("p",[a("strong",[e._v("Compressed Coordinates.")]),e._v(" Compressed coordinates allow contract to work with only "),a("code",[e._v("x")]),e._v(" coordinates and sign bytes. It also prevents errors around points not being on-curve. Conversion to compressed coordinates is trivial.")]),e._v(" "),a("p",[a("strong",[e._v("Linear Combination.")]),e._v(" We could instead have a simple multiply "),a("code",[e._v("C = r ⋅ A")]),e._v(". In this case we would need a separate pre-compile for addition. In addition, a linear combination allows for optimizations that like Shamir's trick that are not available in a single scalar multiplication. ECDSA requires "),a("code",[e._v("s₀ ⋅ A₀ + s₁ ⋅ A₁")]),e._v(" and would benefit from this.")]),e._v(" "),a("p",[e._v("The BN254 (aka alt_bn8) multiplication operation introduced by the "),a("RouterLink",{attrs:{to:"/eip-196.html"}},[e._v("EIP-196")]),e._v(" precompile only handles a single scalar multiplication. The missed performance is such that for two or more points it is cheaper to use EVM, as practically demonstrated by "),a("a",{attrs:{href:"https://medium.com/aztec-protocol/huffing-for-crypto-with-weierstrudel-9c9568c06901",target:"_blank",rel:"noopener noreferrer"}},[e._v("Weierstrudel"),a("OutboundLink")],1),e._v(".")],1),e._v(" "),a("p",[a("strong",[e._v("Variable Time Math.")]),e._v(" When called during a transaction, there is no assumption of privacy and no mitigations for side-channel attacks are necessary.")]),e._v(" "),a("p",[a("strong",[e._v("Prime Fields.")]),e._v(" This EIP is for fields of large characteristic. It does not cover Binary fields and other fields of non-prime characteristic.")]),e._v(" "),a("p",[a("strong",[e._v("256-bit modulus.")]),e._v(" This EIP is for field moduli less than "),a("code",[e._v("2^{256}")]),e._v(". This covers many of the popular curves while still having all parameters fit in a single EVM word.")]),e._v(" "),a("p",[e._v("TODO: Consider a double-word version. 512 bits would cover all known curves except E-521. In particular it will cover the NIST P-384 curve used by the Estonian e-Identity and the BLS12-381 curve used by "),a("a",{attrs:{href:"https://z.cash/blog/new-snark-curve/",target:"_blank",rel:"noopener noreferrer"}},[e._v("ZCash Sappling"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("p",[a("strong",[e._v("Short Weierstrass Curves.")]),e._v(" This EIP is for fields specified in short Weierstrass form. While any curve can be converted to short Weierstrass form through a "),a("a",{attrs:{href:"https://safecurves.cr.yp.to/equation.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("substitution of variables"),a("OutboundLink")],1),e._v(", this misses out on the performance advantages of those specific forms.")]),e._v(" "),a("h2",{attrs:{id:"backwards-compatibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),a("h2",{attrs:{id:"test-cases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test-cases"}},[e._v("#")]),e._v(" Test Cases")]),e._v(" "),a("h2",{attrs:{id:"implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),a("p",[e._v("There will be a reference implementation in Rust based on the existing libraries (in particular those by ZCash and The Matter Inc.).")]),e._v(" "),a("p",[e._v("The reference implementation will be production grade and compile to a native library with a C api and a webassembly version. Node developers are encouraged to use the reference implementation and can use either the rust library, the native C bindings or the webassembly module. Node developers can of course always decide to implement their own.")]),e._v(" "),a("h2",{attrs:{id:"references"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),a("p",[e._v("This EIP overlaps in scope with")]),e._v(" "),a("ul",[a("li",[a("RouterLink",{attrs:{to:"/eip-196.html"}},[e._v("EIP-196")]),e._v(": ecadd, ecmul for altbn128")],1),e._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/ethereum/EIPs/issues/603",target:"_blank",rel:"noopener noreferrer"}},[e._v("EIP issue 603"),a("OutboundLink")],1),e._v(": ecadd, ecmul for SECP256k1.")]),e._v(" "),a("li",[a("RouterLink",{attrs:{to:"/eip-665.html"}},[e._v("EIP-665")]),e._v(": ECDSA verify for ED25519.")],1),e._v(" "),a("li",[a("RouterLink",{attrs:{to:"/eip-1108.html"}},[e._v("EIP-1108")]),e._v(": Optimize ecadd and ecmul for altbn128.")],1)]),e._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),a("p",[e._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),a("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=s.exports}}]);