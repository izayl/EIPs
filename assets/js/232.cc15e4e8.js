(window.webpackJsonp=window.webpackJsonp||[]).push([[232],{627:function(e,t,o){"use strict";o.r(t);var a=o(46),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h2",{attrs:{id:"simple-summary"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[e._v("#")]),e._v(" Simple Summary")]),e._v(" "),o("p",[e._v("Add an option to JSON-RPC filter options (used by "),o("code",[e._v("eth_newFilter")]),e._v(" and "),o("code",[e._v("eth_getLogs")]),e._v(") that allows specifying the block hash that should be included in the results.  This option would be an alternative to "),o("code",[e._v("fromBlock")]),e._v("/"),o("code",[e._v("toBlock")]),e._v(" options.")]),e._v(" "),o("h2",{attrs:{id:"abstract"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),o("p",[e._v("This addition would allow clients to fetch logs for specific blocks, whether those blocks were in the current main chain or not.  This resolves some issues that make it difficult/expensive to author robust clients due to the nature of chain reorgs, unreliable network connections and the result set not containing enough details in the empty case.")]),e._v(" "),o("h2",{attrs:{id:"specification"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),o("p",[e._v("The filter options used by "),o("code",[e._v("eth_newFilter")]),e._v(" would have an additional optional parameter named "),o("code",[e._v("blockHash")]),e._v(" whose value is a single block hash.  The Ethereum node responding to the request would either send back an error if the block hash was not found or it would return the results matching the filter (per normal operation) constrained to the block provided.  Internally, this would function (presumably) similar to the "),o("code",[e._v("fromBlock")]),e._v(" and "),o("code",[e._v("toBlock")]),e._v(" filter options.")]),e._v(" "),o("h2",{attrs:{id:"rationale"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),o("p",[e._v("A client (dApp) who needs reliable notification of both log additions (on new blocks) and log removals (on chain reorgs) cannot achieve this while relying solely on subscriptions and filters.  This is because a combination of a network or remote node failure during a reorg can result in the client getting out of sync with reality.  An example of where this can happen with Websockets is when the client opens a web socket connection, sets up a log filter subscription, gets notified of some new logs, then loses the web socket connection, then (while disconnected) a re-org occurs, then the client connects back and establishes a new log filter.  In this scenario they will not receive notification of the log removals from the node because they were disconnected when the removals were broadcast and the loss of their connection resulted in the node forgetting about their existence.  A similar scenario can be concocted for HTTP clients where between polls for updates, the node goes down and comes back (resulting in loss of filter state) and a re-org also occurs between the same two polls.")]),e._v(" "),o("p",[e._v("In order to deal with this while still providing a robust mechanism for internal block/log additional/removal, the client can maintain a blockchain internally (last "),o("code",[e._v("n")]),e._v(" blocks) and only subscribe/poll for new blocks.  When a new block is received, the client can reconcile their internal model with the new block, potentially back-filling parents or rolling back/removing blocks from their internal model to get in sync with the node.  This can account for any type of disconnect/reorg/outage scenario and also allows the client (as an added benefit) to talk to a cluster of Ethereum nodes (e.g., via round-robin) rather than being tightly coupled to a single node.")]),e._v(" "),o("p",[e._v("Once the user has a reliable stream of blocks, they can then look at the bloom filter for the new block and if the block "),o("em",[e._v("may")]),e._v(" have logs of interest they can fetch the filtered logs for that block from the node.  The problem that arises is that a re-org may occur between when the client receives the block and when the client fetches the logs for that block.  Given the current set of filter options, the client can only ask for logs by block number.  In this scenario, the logs they get back will be for a block that "),o("em",[e._v("isn't")]),e._v(" the block they want the logs for and is instead for a block that was re-orged in (and may not be fully reconciled with the internal client state).  This can be partially worked around by looking at the resulting logs themselves and identifying whether or not they are for the block hash requested.  However, if the result set is an empty array (no logs fetched) then the client is in a situation where they don't know what block the results are for.  The results could have been legitimately empty (bloom filter can yield false positives) for the block in question, or they could be receiving empty logs for a block that they don't know about.  At this point, there is no decision the client can make that allows them a guarantee of recovery.  They can assume the empty logs were for the correct block, but if they weren't then they will never try to fetch again.  This creates a problem if the block was only transiently re-orged out because it may come back before the next block poll so the client will never witness the reorg.  They can assume the empty logs were for the wrong block, an refetch them, but they may continue to get empty results putting them right back into the same situation.")]),e._v(" "),o("p",[e._v("By adding the ability to fetch logs by hash, the client can be guaranteed that if they get a result set, it is for the block in question.  If they get an error, then they can take appropriate action (e.g., rollback that block client-side and re-fetch latest).")]),e._v(" "),o("h2",{attrs:{id:"backwards-compatibility"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),o("p",[e._v("The only potential issue here is the "),o("code",[e._v("fromBlock")]),e._v(" and "),o("code",[e._v("toBlock")]),e._v(" fields.  It wouldn't make sense to include both the hash and the number so it seems like "),o("code",[e._v("fromBlock")]),e._v("/"),o("code",[e._v("toBlock")]),e._v(" should be mutually exclusive with "),o("code",[e._v("blockHash")]),e._v(".")]),e._v(" "),o("h2",{attrs:{id:"test-cases"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#test-cases"}},[e._v("#")]),e._v(" Test Cases")]),e._v(" "),o("p",[o("code",[e._v('{ "jsonrpc": "2.0", "id": 1, "method": "eth_getLogs", params: [{"blockHash": "0xbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0c"}] }')]),e._v(" should return all of the logs for the block with hash "),o("code",[e._v("0xbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0c")]),e._v(".  If a "),o("code",[e._v("topics")]),e._v(" field is added to the filter options then a filtered set of logs for that block should be returned.  If no block exists with that hash then an error should be returned with a "),o("code",[e._v("code")]),e._v(" of "),o("code",[e._v("-32000")]),e._v(", a "),o("code",[e._v("message")]),e._v(" of "),o("code",[e._v('"Block not found."')]),e._v(" and a "),o("code",[e._v("data")]),e._v(" of "),o("code",[e._v('"0xbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0c"')]),e._v(".")]),e._v(" "),o("h2",{attrs:{id:"implementation"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),o("ul",[o("li",[e._v("[x] "),o("a",{attrs:{href:"https://github.com/ethereum/go-ethereum/pull/16734",target:"_blank",rel:"noopener noreferrer"}},[e._v("Geth"),o("OutboundLink")],1)])]),e._v(" "),o("h2",{attrs:{id:"copyright"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),o("p",[e._v("Copyright and related rights waived via "),o("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),o("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=n.exports}}]);