(window.webpackJsonp=window.webpackJsonp||[]).push([[562],{978:function(e,t,a){"use strict";a.r(t);var s=a(46),i=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"simple-summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[e._v("#")]),e._v(" Simple Summary")]),e._v(" "),a("p",[e._v("Add the ability for smart contract to execute calls with a specific amount of gas. If this is not possible the execution should revert.")]),e._v(" "),a("h2",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),a("p",[e._v("The current CALL, DELEGATE_CALL, STATIC_CALL opcode do not enforce the gas being sent, they simply consider the gas value as a maximum. This pose serious problem for applications that require the call to be executed with a precise amount of gas.")]),e._v(" "),a("p",[e._v("This is for example the case for meta-transaction where the contract needs to ensure the call is executed exactly as the signing user intended.")]),e._v(" "),a("p",[e._v('But this is also the case for common use cases, like checking "on-chain" if a smart contract support a specific interface (via '),a("RouterLink",{attrs:{to:"/zh/eip-165.html"}},[e._v("EIP-165")]),e._v(" for example).")],1),e._v(" "),a("p",[e._v("The solution presented here is to add new call semantic that enforce the amount of gas specified : the call either proceed with the exact amount of gas or do not get executed and the current call revert.")]),e._v(" "),a("h3",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),a("p",[e._v("There are 2 possibilities")]),e._v(" "),a("p",[e._v("a) one is to add opcode variant that have a stricter gas semantic")]),e._v(" "),a("p",[e._v("b) The other is to consider a specific gas value range (one that have never been used before) to have strict gas semantic, while leaving other values as before")]),e._v(" "),a("p",[e._v("Here are the details description")]),e._v(" "),a("h4",{attrs:{id:"option-a"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#option-a"}},[e._v("#")]),e._v(" option a)")]),e._v(" "),a("ul",[a("li",[e._v("add a new variant of the CALL opcode where the gas specified is enforced so that if the gas left at the point of call is not enough to give the specified gas to the destination, the current call revert")]),e._v(" "),a("li",[e._v("add a new variant of the DELEGATE_CALL opcode where the gas specified is enforced so that if the gas left at the point of call is not enough to give the specified gas to the destination, the current call revert")]),e._v(" "),a("li",[e._v("add a new variant of the STATIC_CALL opcode where the gas specified is enforced so that if the gas left at the point of call is not enough to give the specified gas to the destination, the current call revert")])]),e._v(" "),a("h5",{attrs:{id:"rational-for-a"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rational-for-a"}},[e._v("#")]),e._v(" Rational for a)")]),e._v(" "),a("p",[e._v("This solution has the merit to avoid any possibility of old contract be affected by the change. On the other hand it introduce 3 new opcodes. With EIP-1702, we could render the old opcode obsolete though.")]),e._v(" "),a("h4",{attrs:{id:"option-b"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#option-b"}},[e._v("#")]),e._v(" option b)")]),e._v(" "),a("p",[e._v("For all opcode that allow to pass gas to another contract, do the following:")]),e._v(" "),a("ul",[a("li",[e._v("If the most significant bit is one, consider the 31 less significant bit as the amount of gas to be given to the receiving contract in the strict sense. SO like a) if the gas left at the point of call is not enough to give the specified gas to the destination, the current call revert.")]),e._v(" "),a("li",[e._v("If the 2nd most significant bit is zero, consider the whole value to behave like before, that is, it act as a maximum value, and even if not enough gas is present, the gas that can be given is given to the receiving contract")])]),e._v(" "),a("h5",{attrs:{id:"rational-for-b"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rational-for-b"}},[e._v("#")]),e._v(" Rational for b)")]),e._v(" "),a("p",[e._v("This solution relies on the fact that no contract would have given any value bigger or equal to 0x8000000000000000000000000000000000000000000000000000000000000000")]),e._v(" "),a("p",[e._v("Note that solidity for example do not use value like 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF as it is more expensive than passing the gasLeft.")]),e._v(" "),a("p",[e._v("Its main benefit though is that it does not require extra opcodes.")]),e._v(" "),a("h4",{attrs:{id:"strict-gas-semantic"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#strict-gas-semantic"}},[e._v("#")]),e._v(" strict gas semantic")]),e._v(" "),a("p",[e._v("To be precise, regarding the strict gas semantic, based on "),a("RouterLink",{attrs:{to:"/zh/eip-150.html"}},[e._v("EIP-150")]),e._v(", the current call must revert unless G >= I x 64/63 where G is gas left at the point of call (after deducing the cost of the call itself) and I is the gas specified.")],1),e._v(" "),a("p",[e._v("So instead of")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("availableGas = availableGas - base\ngas := availableGas - availableGas/64\n...\nif !callCost.IsUint64() || gas < callCost.Uint64() {\n    return gas, nil\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])]),a("p",[e._v("see https://github.com/ethereum/go-ethereum/blob/7504dbd6eb3f62371f86b06b03ffd665690951f2/core/vm/gas.go#L41-L48")]),e._v(" "),a("p",[e._v("we would have")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("availableGas = availableGas - base\ngas := availableGas - availableGas/64\nif !callCost.IsUint64() || gas < callCost.Uint64() {\n    return 0, errNotEnoughGas\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("h3",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),a("p",[e._v("Currently the gas specified as part of these opcodes is simply a maximum value. And due to the behavior of "),a("RouterLink",{attrs:{to:"/zh/eip-150.html"}},[e._v("EIP-150")]),e._v(" it is possible for an external call to be given less gas than intended (less than the gas specified as part of the CALL) while the rest of the current call is given enough to continue and succeed. Indeed since with EIP-150, the external call is given at max  "),a("code",[e._v("G - Math.floor(G/64)")]),e._v(" where G is the gasleft() at the point of the CALL, the rest of the current call is given "),a("code",[e._v("Math.floor(G/64)")]),e._v(" which can be plenty enough for the transaction to succeed. For example, when G = 6,400,000 the rest of the transaction will be given 100,000 gas plenty enough in many case to succeed.")],1),e._v(" "),a("p",[e._v("This is an issue for contracts that require external call to only fails if they would fails with enough gas. This requirement is present in smart contract wallet and meta transaction in general, where the one executing the transaction is not the signer of the execution data. Because in such case, the contract needs to ensure the call is executed exactly as the signing user intended.")]),e._v(" "),a("p",[e._v("But this is also true for simple use case, like checking if a contract implement an interface via EIP-165. Indeed as specified by such EIP, the "),a("code",[e._v("supporstInterface")]),e._v(" method is bounded to use 30,000 gas so that it is theorically possible to ensure that the throw is not a result of a lack of gas. Unfortunately due to how the different CALL opcodes behave contracts can't simply rely on the gas value specified. They have to ensure by other means that there is enough gas for the call.")]),e._v(" "),a("p",[e._v("Indeed, if the caller do not ensure that 30,000 gas or more is provided to the callee, the callee might throw because of a lack of gas (and not because it does not support the interface), and the parent call will be given up to 476 gas to continue. This would result in the caller interpreting wrongly that the callee is not implementing the interface in question.")]),e._v(" "),a("p",[e._v("While such requirement can be enforced by checking the gas left according to EIP-150 and the precise gas required before the call (see solution presented in that "),a("a",{attrs:{href:"https://web.solidified.io/contract/5b4769b1e6c0d80014f3ea4e/bug/5c83d86ac2dd6600116381f9",target:"_blank",rel:"noopener noreferrer"}},[e._v("bug report"),a("OutboundLink")],1),e._v(" or after the call (see the native meta transaction implementation "),a("a",{attrs:{href:"https://github.com/pixowl/thesandbox-contracts/blob/623f4d4ca10644dcee145bcbd9296579a1543d3d/src/Sand/erc20/ERC20MetaTxExtension.sol#L176",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),a("OutboundLink")],1),e._v(", it would be much better if the EVM allowed us to strictly specify how much gas is to be given to the CALL so contract implementations do not need to follow "),a("RouterLink",{attrs:{to:"/zh/eip-150.html"}},[e._v("EIP-150")]),e._v(" behavior and the current gas pricing so closely.")],1),e._v(" "),a("p",[e._v("This would also allow the behaviour of "),a("RouterLink",{attrs:{to:"/zh/eip-150.html"}},[e._v("EIP-150")]),e._v(" to be changed without having to affect contract that require this strict gas behaviour.")],1),e._v(" "),a("p",[e._v("As mentioned, such strict gas behaviour is important for smart contract wallet and meta transaction in general. The issue is actually already a problem in the wild as can be seen in the case of Gnosis safe which did not consider the behavior of EIP-150 and thus fails to check the gas properly, requiring the safe owners to add otherwise unnecessary extra gas to their signed message to avoid the possibility of losing funds. See https://github.com/gnosis/safe-contracts/issues/100")]),e._v(" "),a("p",[e._v("As for EIP-165, the issue already exists in the example implementation presented in the EIP. Please see the details of the issue "),a("a",{attrs:{href:"https://github.com/ethereum/EIPs/pull/881#issuecomment-491677748",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("The same issue exists also on OpenZeppelin implementation, a library used by many. It does not for perform any check on gas before calling "),a("code",[e._v("supportsInterface")]),e._v(" with 30,000 gas (see "),a("a",{attrs:{href:"https://github.com/OpenZeppelin/openzeppelin-solidity/blob/fa004a7f5de572b3dbcde1a8a81f9a87e353e799/contracts/introspection/ERC165Checker.sol#L37",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),a("OutboundLink")],1),e._v(" and is thus vulnerable to the issue mentioned.")]),e._v(" "),a("p",[e._v("While such issue can be prevented today by checking the gas with EIP-150 in mind, a solution at the opcode level is more elegant.")]),e._v(" "),a("p",[e._v("Indeed, the two possible ways to currently enforce that the correct amount of gas is sent are as follow :")]),e._v(" "),a("ol",[a("li",[e._v("check done before the call")])]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('uint256 gasAvailable = gasleft() - E;\nrequire(gasAvailable - gasAvailable / 64  >= `txGas`, "not enough gas provided")\nto.call.gas(txGas)(data); // CALL\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("where E is the gas required for the operation between the call to "),a("code",[e._v("gasleft()")]),e._v(" and the actual call PLUS the gas cost of the call itself. While it is possible to simply over estimate "),a("code",[e._v("E")]),e._v(" to prevent call to be executed if not enough gas is provided to the current call it would be better to have the EVM do the precise work itself. As gas pricing continue to evolve, this is important to have a mechanism to ensure a specific amount of gas is passed to the call so such mechanism can be used without having to relies on a specific gas pricing.")]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[e._v("check done after the call:")])]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('to.call.gas(txGas)(data); // CALL\nrequire(gasleft() > txGas / 63, "not enough gas left");\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("This solution does not require to compute a "),a("code",[e._v("E")]),e._v(" value and thus do not relies on a specific gas pricing (except for the behaviour of EIP-150) since if the call is given not enough gas and fails for that reason, the condition above will always fail, ensuring the current call will revert. But this check still pass if the gas given was less AND the external call reverted or succeeded EARLY (so that the gas left after the call > txGas / 63). This can be an issue if the code executed as part of the CALL is reverting as a result of a check against the gas provided. Like a meta transaction in a meta transaction.")]),e._v(" "),a("p",[e._v("Similarly to the the previous solution, an EVM mechanism would be much better.")]),e._v(" "),a("h2",{attrs:{id:"backwards-compatibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),a("p",[e._v("for specification a) : Backwards compatible as it introduce new opcodes.")]),e._v(" "),a("p",[e._v("for specification b) : Backwards compatible as it use value range outside of what is used by existing contract (to be verified)")]),e._v(" "),a("h2",{attrs:{id:"test-cases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test-cases"}},[e._v("#")]),e._v(" Test Cases")]),e._v(" "),a("h2",{attrs:{id:"implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),a("p",[e._v("None fully implemented yet. But see Specifications for an example in geth.")]),e._v(" "),a("h2",{attrs:{id:"references"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),a("ol",[a("li",[e._v("EIP-150, ./eip-150.md")])]),e._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),a("p",[e._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),a("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=i.exports}}]);