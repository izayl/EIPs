(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{369:function(e,t,v){e.exports=v.p+"assets/img/state.d7739b64.png"},932:function(e,t,v){"use strict";v.r(t);var a=v(46),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),a("p",[e._v("This EIP proposes net gas metering changes for "),a("code",[e._v("SSTORE")]),e._v(" opcode, enabling\nnew usages for contract storage, and reducing excessive gas costs\nwhere it doesn't match how most implementation works.")]),e._v(" "),a("p",[e._v("This acts as an alternative for EIP-1087, where it tries to be\nfriendlier to implementations that use different optimization\nstrategies for storage change caches.")]),e._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),a("p",[e._v("This EIP proposes a way for gas metering on SSTORE (as an alternative\nfor EIP-1087 and EIP-1153), using information that is more universally\navailable to most implementations, and require as little change in\nimplementation structures as possible.")]),e._v(" "),a("ul",[a("li",[a("em",[e._v("Storage slot's original value")]),e._v(".")]),e._v(" "),a("li",[a("em",[e._v("Storage slot's current value")]),e._v(".")]),e._v(" "),a("li",[e._v("Refund counter.")])]),e._v(" "),a("p",[e._v("Usages that benefits from this EIP's gas reduction scheme includes:")]),e._v(" "),a("ul",[a("li",[e._v("Subsequent storage write operations within the same call frame. This\nincludes reentry locks, same-contract multi-send, etc.")]),e._v(" "),a("li",[e._v("Exchange storage information between sub call frame and parent call\nframe, where this information does not need to be persistent outside\nof a transaction. This includes sub-frame error codes and message\npassing, etc.")])]),e._v(" "),a("h2",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),a("p",[e._v("Definitions of terms are as below:")]),e._v(" "),a("ul",[a("li",[a("em",[e._v("Storage slot's original value")]),e._v(": This is the value of the storage if\na reversion happens on the "),a("em",[e._v("current transaction")]),e._v(".")]),e._v(" "),a("li",[a("em",[e._v("Storage slot's current value")]),e._v(": This is the value of the storage\nbefore SSTORE operation happens.")]),e._v(" "),a("li",[a("em",[e._v("Storage slot's new value")]),e._v(": This is the value of the storage after\nSSTORE operation happens.")])]),e._v(" "),a("p",[e._v("Replace "),a("code",[e._v("SSTORE")]),e._v(" opcode gas cost calculation (including refunds) with\nthe following logic:")]),e._v(" "),a("ul",[a("li",[e._v("If "),a("em",[e._v("current value")]),e._v(" equals "),a("em",[e._v("new value")]),e._v(" (this is a no-op), 200 gas is\ndeducted.")]),e._v(" "),a("li",[e._v("If "),a("em",[e._v("current value")]),e._v(" does not equal "),a("em",[e._v("new value")]),e._v(" "),a("ul",[a("li",[e._v("If "),a("em",[e._v("original value")]),e._v(" equals "),a("em",[e._v("current value")]),e._v(" (this storage slot has\nnot been changed by the current execution context)\n"),a("ul",[a("li",[e._v("If "),a("em",[e._v("original value")]),e._v(" is 0, 20000 gas is deducted.")]),e._v(" "),a("li",[e._v("Otherwise, 5000 gas is deducted. If "),a("em",[e._v("new value")]),e._v(" is 0, add 15000\ngas to refund counter.")])])]),e._v(" "),a("li",[e._v("If "),a("em",[e._v("original value")]),e._v(" does not equal "),a("em",[e._v("current value")]),e._v(" (this storage\nslot is dirty), 200 gas is deducted. Apply both of the following\nclauses.\n"),a("ul",[a("li",[e._v("If "),a("em",[e._v("original value")]),e._v(" is not 0\n"),a("ul",[a("li",[e._v("If "),a("em",[e._v("current value")]),e._v(" is 0 (also means that "),a("em",[e._v("new value")]),e._v(" is not\n0), remove 15000 gas from refund counter. We can prove that\nrefund counter will never go below 0.")]),e._v(" "),a("li",[e._v("If "),a("em",[e._v("new value")]),e._v(" is 0 (also means that "),a("em",[e._v("current value")]),e._v(" is not\n0), add 15000 gas to refund counter.")])])]),e._v(" "),a("li",[e._v("If "),a("em",[e._v("original value")]),e._v(" equals "),a("em",[e._v("new value")]),e._v(" (this storage slot is\nreset)\n"),a("ul",[a("li",[e._v("If "),a("em",[e._v("original value")]),e._v(" is 0, add 19800 gas to refund counter.")]),e._v(" "),a("li",[e._v("Otherwise, add 4800 gas to refund counter.")])])])])])])])]),e._v(" "),a("p",[e._v("Refund counter works as before -- it is limited to half of the gas\nconsumed. On a transaction level, refund counter will never go below\nzero. However, there are some important notes depending on the\nimplementation details:")]),e._v(" "),a("ul",[a("li",[e._v('If an implementation uses "transaction level" refund counter (refund\nis checkpointed at each call frame), then the refund counter\ncontinues to be unsigned.')]),e._v(" "),a("li",[e._v('If an implementation uses "execution-frame level" refund counter\n(a new refund counter is created at each call frame, and then merged\nback to parent when the call frame finishes), then the refund\ncounter needs to be changed to signed -- at internal calls, a child\nrefund can go below zero.')])]),e._v(" "),a("h2",{attrs:{id:"explanation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#explanation"}},[e._v("#")]),e._v(" Explanation")]),e._v(" "),a("p",[e._v("The new gas cost scheme for "),a("code",[e._v("SSTORE")]),e._v(" is divided into three different\ntypes:")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("No-op")]),e._v(": the virtual machine does not need to do anything. This is\nthe case if "),a("em",[e._v("current value")]),e._v(" equals "),a("em",[e._v("new value")]),e._v(".")]),e._v(" "),a("li",[a("strong",[e._v("Fresh")]),e._v(": this storage slot has not been changed, or has been reset\nto its original value. This is the case if "),a("em",[e._v("current value")]),e._v(" does not\nequal "),a("em",[e._v("new value")]),e._v(", and "),a("em",[e._v("original value")]),e._v(" equals "),a("em",[e._v("current value")]),e._v(".")]),e._v(" "),a("li",[a("strong",[e._v("Dirty")]),e._v(": this storage slot has already been changed. This is the\ncase if "),a("em",[e._v("current value")]),e._v(" does not equal "),a("em",[e._v("new value")]),e._v(", and "),a("em",[e._v("original\nvalue")]),e._v(" does not equal "),a("em",[e._v("current value")]),e._v(".")])]),e._v(" "),a("p",[e._v("We can see that the above three types cover all possible variations of\n"),a("em",[e._v("original value")]),e._v(", "),a("em",[e._v("current value")]),e._v(", and "),a("em",[e._v("new value")]),e._v(".")]),e._v(" "),a("p",[a("strong",[e._v("No-op")]),e._v(" is a trivial operation. Below we only consider cases for\n"),a("strong",[e._v("Fresh")]),e._v(" and "),a("strong",[e._v("Dirty")]),e._v(".")]),e._v(" "),a("p",[e._v("All initial (not-"),a("strong",[e._v("No-op")]),e._v(") "),a("code",[e._v("SSTORE")]),e._v(" on a particular storage slot starts\nwith "),a("strong",[e._v("Fresh")]),e._v(". After that, it will become "),a("strong",[e._v("Dirty")]),e._v(" if the value has\nbeen changed. When going from "),a("strong",[e._v("Fresh")]),e._v(" to "),a("strong",[e._v("Dirty")]),e._v(", we charge the\ngas cost the same as current scheme. A "),a("strong",[e._v("Dirty")]),e._v(" storage slot can be\nreset back to "),a("strong",[e._v("Fresh")]),e._v(" via a "),a("code",[e._v("SSTORE")]),e._v(" opcode. This will trigger a\nrefund.")]),e._v(" "),a("p",[e._v("When a storage slot remains at "),a("strong",[e._v("Dirty")]),e._v(", we charge 200 gas. In this\ncase, we would also need to keep track of "),a("code",[e._v("R_SCLEAR")]),e._v(" refunds -- if we\nalready issued the refund but it no longer applies ("),a("em",[e._v("current value")]),e._v(" is\n0), then removes this refund from the refund counter. If we didn't\nissue the refund but it applies now ("),a("em",[e._v("new value")]),e._v(" is 0), then adds this\nrefund to the refund counter. It is not possible where a refund is not\nissued but we remove the refund in the above case, because all storage\nslot starts with "),a("strong",[e._v("Fresh")]),e._v(" state.")]),e._v(" "),a("h3",{attrs:{id:"state-transition"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#state-transition"}},[e._v("#")]),e._v(" State Transition")]),e._v(" "),a("p",[e._v("Below is a graph ("),a("a",{attrs:{href:"https://github.com/ethereum/EIPs/pull/1283#issuecomment-410229053",target:"_blank",rel:"noopener noreferrer"}},[e._v("by\n@Arachnid"),a("OutboundLink")],1),e._v(")\nshowing possible state transition of gas costs. We ignore "),a("strong",[e._v("No-op")]),e._v("\nstate because that is trivial:")]),e._v(" "),a("p",[a("img",{attrs:{src:v(369),alt:"State Transition"}})]),e._v(" "),a("p",[e._v("Below is table version of the above diagram. Vertical shows the "),a("em",[e._v("new\nvalue")]),e._v(" being set, and horizontal shows the state of "),a("em",[e._v("original value")]),e._v("\nand "),a("em",[e._v("current value")]),e._v(".")]),e._v(" "),a("p",[e._v("When "),a("em",[e._v("original value")]),e._v(" is 0:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th"),e._v(" "),a("th",[e._v("A ("),a("code",[e._v("current=orig=0")]),e._v(")")]),e._v(" "),a("th",[e._v("B ("),a("code",[e._v("current!=orig")]),e._v(")")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("~0")]),e._v(" "),a("td",[e._v("B; 20k gas")]),e._v(" "),a("td",[e._v("B; 200 gas")])]),e._v(" "),a("tr",[a("td",[e._v("0")]),e._v(" "),a("td",[e._v("A; 200 gas")]),e._v(" "),a("td",[e._v("A; 200 gas, 19.8k refund")])])])]),e._v(" "),a("p",[e._v("When "),a("em",[e._v("original value")]),e._v(" is not 0:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th"),e._v(" "),a("th",[e._v("X ("),a("code",[e._v("current=orig!=0")]),e._v(")")]),e._v(" "),a("th",[e._v("Y ("),a("code",[e._v("current!=orig")]),e._v(")")]),e._v(" "),a("th",[e._v("Z ("),a("code",[e._v("current=0")]),e._v(")")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[a("code",[e._v("orig")])]),e._v(" "),a("td",[e._v("X; 200 gas")]),e._v(" "),a("td",[e._v("X; 200 gas, 4.8k refund")]),e._v(" "),a("td",[e._v("X; 200 gas, -10.2k refund")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("~orig, ~0")])]),e._v(" "),a("td",[e._v("Y; 5k gas")]),e._v(" "),a("td",[e._v("Y; 200 gas")]),e._v(" "),a("td",[e._v("Y; 200 gas, -15k refund")])]),e._v(" "),a("tr",[a("td",[e._v("0")]),e._v(" "),a("td",[e._v("Z; 5k gas, 15k refund")]),e._v(" "),a("td",[e._v("Z; 200 gas, 15k refund")]),e._v(" "),a("td",[e._v("Z; 200 gas")])])])]),e._v(" "),a("h2",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),a("p",[e._v('This EIP mostly achieves what a transient storage tries to do\n(EIP-1087 and EIP-1153), but without the complexity of introducing the\nconcept of "dirty maps", or an extra storage struct.')]),e._v(" "),a("ul",[a("li",[e._v("We don't suffer from the optimization limitation of\nEIP-1087. EIP-1087 requires keeping a dirty map for storage changes,\nand implicitly makes the assumption that a transaction's storage\nchanges are committed to the storage trie at the end of a\ntransaction. This works well for some implementations, but not for\nothers. After EIP-658, an efficient storage cache implementation\nwould probably use an in-memory trie (without RLP encoding/decoding)\nor other immutable data structures to keep track of storage changes,\nand only commit changes at the end of a block. For them, it is\npossible to know a storage's original value and current value, but\nit is not possible to iterate over all storage changes without\nincurring additional memory or processing costs.")]),e._v(" "),a("li",[e._v("It never costs more gas compared with the current scheme.")]),e._v(" "),a("li",[e._v("It covers all usages for a transient storage. Clients that are easy\nto implement EIP-1087 will also be easy to implement this\nspecification. Some other clients might require a little bit extra\nrefactoring on this. Nonetheless, no extra memory or processing cost\nis needed on runtime.")])]),e._v(" "),a("p",[e._v("Regarding "),a("code",[e._v("SSTORE")]),e._v(" gas cost and refunds, see Appendix for proofs of\nproperties that this EIP satisfies.")]),e._v(" "),a("ul",[a("li",[e._v("For "),a("em",[e._v("absolute gas used")]),e._v(" (that is, actual "),a("em",[e._v("gas used")]),e._v(" minus "),a("em",[e._v("refund")]),e._v("),\nthis EIP is equivalent to EIP-1087 for all cases.")]),e._v(" "),a("li",[e._v("For one particular case, where a storage slot is changed, reset to\nits original value, and then changed again, EIP-1283 would move more\ngases to refund counter compared with EIP-1087.")])]),e._v(" "),a("p",[e._v("Examine examples provided in EIP-1087's Motivation:")]),e._v(" "),a("ul",[a("li",[e._v("If a contract with empty storage sets slot 0 to 1, then back to 0,\nit will be charged "),a("code",[e._v("20000 + 200 - 19800 = 400")]),e._v(" gas.")]),e._v(" "),a("li",[e._v("A contract with empty storage that increments slot 0 5 times will be\ncharged "),a("code",[e._v("20000 + 5 * 200 = 21000")]),e._v(" gas.")]),e._v(" "),a("li",[e._v("A balance transfer from account A to account B followed by a\ntransfer from B to C, with all accounts having nonzero starting and\nending balances, it will cost "),a("code",[e._v("5000 * 3 + 200 - 4800 = 10400")]),e._v(" gas.")])]),e._v(" "),a("h2",{attrs:{id:"backwards-compatibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),a("p",[e._v("This EIP requires a hard fork to implement. No gas cost increase is\nanticipated, and many contracts will see gas reduction.")]),e._v(" "),a("h2",{attrs:{id:"test-cases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test-cases"}},[e._v("#")]),e._v(" Test Cases")]),e._v(" "),a("p",[e._v("Below we provide 17 test cases. 15 of them covering consecutive two\n"),a("code",[e._v("SSTORE")]),e._v(" operations are based on work "),a("a",{attrs:{href:"https://github.com/ethereum/tests/issues/483",target:"_blank",rel:"noopener noreferrer"}},[e._v("by\n@chfast"),a("OutboundLink")],1),e._v(". Two additional\ncase with three "),a("code",[e._v("SSTORE")]),e._v(" operations is used to test the case when a\nslot is reset and then set again.")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Code")]),e._v(" "),a("th",[e._v("Used Gas")]),e._v(" "),a("th",[e._v("Refund")]),e._v(" "),a("th",[e._v("Original")]),e._v(" "),a("th",[e._v("1st")]),e._v(" "),a("th",[e._v("2nd")]),e._v(" "),a("th",[e._v("3rd")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[a("code",[e._v("0x60006000556000600055")])]),e._v(" "),a("td",[e._v("412")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("0x60006000556001600055")])]),e._v(" "),a("td",[e._v("20212")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("0x60016000556000600055")])]),e._v(" "),a("td",[e._v("20212")]),e._v(" "),a("td",[e._v("19800")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("0x60016000556002600055")])]),e._v(" "),a("td",[e._v("20212")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td",[e._v("2")]),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("0x60016000556001600055")])]),e._v(" "),a("td",[e._v("20212")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("0x60006000556000600055")])]),e._v(" "),a("td",[e._v("5212")]),e._v(" "),a("td",[e._v("15000")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("0x60006000556001600055")])]),e._v(" "),a("td",[e._v("5212")]),e._v(" "),a("td",[e._v("4800")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("0x60006000556002600055")])]),e._v(" "),a("td",[e._v("5212")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td",[e._v("2")]),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("0x60026000556000600055")])]),e._v(" "),a("td",[e._v("5212")]),e._v(" "),a("td",[e._v("15000")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td",[e._v("2")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("0x60026000556003600055")])]),e._v(" "),a("td",[e._v("5212")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td",[e._v("2")]),e._v(" "),a("td",[e._v("3")]),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("0x60026000556001600055")])]),e._v(" "),a("td",[e._v("5212")]),e._v(" "),a("td",[e._v("4800")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td",[e._v("2")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("0x60026000556002600055")])]),e._v(" "),a("td",[e._v("5212")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td",[e._v("2")]),e._v(" "),a("td",[e._v("2")]),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("0x60016000556000600055")])]),e._v(" "),a("td",[e._v("5212")]),e._v(" "),a("td",[e._v("15000")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("0x60016000556002600055")])]),e._v(" "),a("td",[e._v("5212")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td",[e._v("2")]),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("0x60016000556001600055")])]),e._v(" "),a("td",[e._v("412")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td")]),e._v(" "),a("tr",[a("td",[a("code",[e._v("0x600160005560006000556001600055")])]),e._v(" "),a("td",[e._v("40218")]),e._v(" "),a("td",[e._v("19800")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td",[e._v("1")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("0x600060005560016000556000600055")])]),e._v(" "),a("td",[e._v("10218")]),e._v(" "),a("td",[e._v("19800")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td",[e._v("0")]),e._v(" "),a("td",[e._v("1")]),e._v(" "),a("td",[e._v("0")])])])]),e._v(" "),a("h2",{attrs:{id:"appendix-proof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#appendix-proof"}},[e._v("#")]),e._v(" Appendix: Proof")]),e._v(" "),a("p",[e._v("Because the "),a("em",[e._v("storage slot's original value")]),e._v(" is defined as the value\nwhen a reversion happens on the "),a("em",[e._v("current transaction")]),e._v(", it's easy to\nsee that call frames won't interfere SSTORE gas calculation. So\nalthough the below proof is discussed without call frames, it applies\nto all situations with call frames. We will discuss the case\nseparately for "),a("em",[e._v("original value")]),e._v(" being zero and not zero, and use\n"),a("em",[e._v("induction")]),e._v(" to prove some properties of SSTORE gas cost.")]),e._v(" "),a("p",[a("em",[e._v("Final value")]),e._v(" is the value of a particular storage slot at the end of\na transaction. "),a("em",[e._v("Absolute gas used")]),e._v(" is the absolute value of "),a("em",[e._v("gas used")]),e._v("\nminus "),a("em",[e._v("refund")]),e._v(". We use "),a("code",[e._v("N")]),e._v(" to represent the total number of SSTORE\noperations on a storage slot. For states discussed below, refer to\n"),a("em",[e._v("State Transition")]),e._v(" in "),a("em",[e._v("Explanation")]),e._v(" section.")]),e._v(" "),a("h3",{attrs:{id:"original-value-being-zero"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#original-value-being-zero"}},[e._v("#")]),e._v(" Original Value Being Zero")]),e._v(" "),a("p",[e._v("When "),a("em",[e._v("original value")]),e._v(" is 0, we want to prove that:")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("Case I")]),e._v(": If the "),a("em",[e._v("final value")]),e._v(" ends up still being 0, we want to charge "),a("code",[e._v("200 * N")]),e._v(" gases, because no disk write is needed.")]),e._v(" "),a("li",[a("strong",[e._v("Case II")]),e._v(": If the "),a("em",[e._v("final value")]),e._v(" ends up being a non-zero value, we want to\ncharge "),a("code",[e._v("20000 + 200 * (N-1)")]),e._v(" gas, because it requires writing this\nslot to disk.")])]),e._v(" "),a("h4",{attrs:{id:"base-case"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#base-case"}},[e._v("#")]),e._v(" Base Case")]),e._v(" "),a("p",[e._v("We always start at state A. The first SSTORE can:")]),e._v(" "),a("ul",[a("li",[e._v("Go to state A: 200 gas is deducted. We satisfy "),a("em",[e._v("Case I")]),e._v(" because\n"),a("code",[e._v("200 * N == 200 * 1")]),e._v(".")]),e._v(" "),a("li",[e._v("Go to state B: 20000 gas is deducted. We satisfy "),a("em",[e._v("Case II")]),e._v(" because\n"),a("code",[e._v("20000 + 200 * (N-1) == 20000 + 200 * 0")]),e._v(".")])]),e._v(" "),a("h4",{attrs:{id:"inductive-step"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#inductive-step"}},[e._v("#")]),e._v(" Inductive Step")]),e._v(" "),a("ul",[a("li",[e._v("From A to A. The previous gas cost is "),a("code",[e._v("200 * (N-1)")]),e._v(". The current\ngas cost is "),a("code",[e._v("200 + 200 * (N-1)")]),e._v(". It satisfy "),a("em",[e._v("Case I")]),e._v(".")]),e._v(" "),a("li",[e._v("From A to B. The previous gas cost is "),a("code",[e._v("200 * (N-1)")]),e._v(". The current\ngas cost is "),a("code",[e._v("20000 + 200 * (N-1)")]),e._v(". It satisfy "),a("em",[e._v("Case II")]),e._v(".")]),e._v(" "),a("li",[e._v("From B to B. The previous gas cost is "),a("code",[e._v("20000 + 200 * (N-2)")]),e._v(". The\ncurrent gas cost is "),a("code",[e._v("200 + 20000 + 200 * (N-2)")]),e._v(". It satisfy\n"),a("em",[e._v("Case II")]),e._v(".")]),e._v(" "),a("li",[e._v("From B to A. The previous gas cost is "),a("code",[e._v("20000 + 200 * (N-2)")]),e._v(". The\ncurrent gas cost is "),a("code",[e._v("200 - 19800 + 20000 + 200 * (N-2)")]),e._v(". It satisfy\n"),a("em",[e._v("Case I")]),e._v(".")])]),e._v(" "),a("h3",{attrs:{id:"original-value-not-being-zero"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#original-value-not-being-zero"}},[e._v("#")]),e._v(" Original Value Not Being Zero")]),e._v(" "),a("p",[e._v("When "),a("em",[e._v("original value")]),e._v(" is not 0, we want to prove that:")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("Case I")]),e._v(": If the "),a("em",[e._v("final value")]),e._v(" ends up unchanged, we want to\ncharge "),a("code",[e._v("200 * N")]),e._v(" gases, because no disk write is needed.")]),e._v(" "),a("li",[a("strong",[e._v("Case II")]),e._v(": If the "),a("em",[e._v("final value")]),e._v(" ends up being zero, we want to\ncharge "),a("code",[e._v("5000 - 15000 + 200 * (N-1)")]),e._v(" gas. Note that "),a("code",[e._v("15000")]),e._v(" is the\nrefund in actual definition.")]),e._v(" "),a("li",[a("strong",[e._v("Case III")]),e._v(": If the "),a("em",[e._v("final value")]),e._v(" ends up being a changed non-zero\nvalue, we want to charge "),a("code",[e._v("5000 + 200 * (N-1)")]),e._v(" gas.")])]),e._v(" "),a("h4",{attrs:{id:"base-case-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#base-case-2"}},[e._v("#")]),e._v(" Base Case")]),e._v(" "),a("p",[e._v("We always start at state X. The first SSTORE can:")]),e._v(" "),a("ul",[a("li",[e._v("Go to state X: 200 gas is deducted. We satisfy "),a("em",[e._v("Case I")]),e._v(" because\n"),a("code",[e._v("200 * N == 200 * 1")]),e._v(".")]),e._v(" "),a("li",[e._v("Go to state Y: 5000 gas is deducted. We satisfy "),a("em",[e._v("Case III")]),e._v(" because\n"),a("code",[e._v("5000 + 200 * (N-1) == 5000 + 200 * 0")]),e._v(".")]),e._v(" "),a("li",[e._v("Go to state Z: The absolute gas used is "),a("code",[e._v("5000 - 15000")]),e._v(" where 15000\nis the refund. We satisfy "),a("em",[e._v("Case II")]),e._v(" because "),a("code",[e._v("5000 - 15000 + 200 * (N-1) == 5000 - 15000 + 200 * 0")]),e._v(".")])]),e._v(" "),a("h4",{attrs:{id:"inductive-step-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#inductive-step-2"}},[e._v("#")]),e._v(" Inductive Step")]),e._v(" "),a("ul",[a("li",[e._v("From X to X. The previous gas cost is "),a("code",[e._v("200 * (N-1)")]),e._v(". The current gas\ncost is "),a("code",[e._v("200 + 200 * (N-1)")]),e._v(". It satisfy "),a("em",[e._v("Case I")]),e._v(".")]),e._v(" "),a("li",[e._v("From X to Y. The previous gas cost is "),a("code",[e._v("200 * (N-1)")]),e._v(". The current gas\ncost is "),a("code",[e._v("5000 + 200 * (N-1)")]),e._v(". It satisfy "),a("em",[e._v("Case III")]),e._v(".")]),e._v(" "),a("li",[e._v("From X to Z. The previous gas cost is "),a("code",[e._v("200 * (N-1)")]),e._v(". The current\nabsolute gas cost is "),a("code",[e._v("5000 - 15000 + 200 * (N-1)")]),e._v(". It satisfy "),a("em",[e._v("Case\nII")]),e._v(".")]),e._v(" "),a("li",[e._v("From Y to X. The previous gas cost is "),a("code",[e._v("5000 + 200 * (N-2)")]),e._v(". The\nabsolute current gas cost is "),a("code",[e._v("200 - 4800 + 5000 + 200 * (N-2)")]),e._v(". It\nsatisfy "),a("em",[e._v("Case I")]),e._v(".")]),e._v(" "),a("li",[e._v("From Y to Y. The previous gas cost is "),a("code",[e._v("5000 + 200 * (N-2)")]),e._v(". The\ncurrent gas cost is "),a("code",[e._v("200 + 5000 + 200 * (N-2)")]),e._v(". It satisfy "),a("em",[e._v("Case\nIII")]),e._v(".")]),e._v(" "),a("li",[e._v("From Y to Z. The previous gas cost is "),a("code",[e._v("5000 + 200 * (N-2)")]),e._v(". The\ncurrent absolute gas cost is "),a("code",[e._v("200 - 15000 + 5000 + 200 * (N-2)")]),e._v(". It\nsatisfy "),a("em",[e._v("Case II")]),e._v(".")]),e._v(" "),a("li",[e._v("From Z to X. The previous gas cost is "),a("code",[e._v("5000 - 15000 + 200 * (N-2)")]),e._v(". The current absolute gas cost is "),a("code",[e._v("200 + 10200 + 5000 - 15000 + 200 * (N-2)")]),e._v(". It satisfy "),a("em",[e._v("Case I")]),e._v(".")]),e._v(" "),a("li",[e._v("From Z to Y. The previous gas cost is "),a("code",[e._v("5000 - 15000 + 200 * (N-2)")]),e._v(". The current absolute gas cost is "),a("code",[e._v("200 + 15000 + 5000 - 15000 + 200 * (N-2)")]),e._v(". It satisfy "),a("em",[e._v("Case III")]),e._v(".")]),e._v(" "),a("li",[e._v("From Z to Z. The previous gas cost is "),a("code",[e._v("5000 - 15000 + 200 * (N-2)")]),e._v(". The current absolute gas cost is "),a("code",[e._v("200 + 5000 - 15000 + 200 * (N-2)")]),e._v(". It satisfy "),a("em",[e._v("Case II")]),e._v(".")])]),e._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),a("p",[e._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),a("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=s.exports}}]);