(window.webpackJsonp=window.webpackJsonp||[]).push([[97],{506:function(e,t,n){"use strict";n.r(t);var r=n(46),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"abstract"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),n("p",[e._v("This document describes a scheme for authenticated, updateable Ethereum node\nlists retrievable via DNS.")]),e._v(" "),n("h1",{attrs:{id:"motivation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),n("p",[e._v("Many Ethereum clients contain hard-coded bootstrap node lists. Updating those\nlists requires a software update. The current lists are small, giving the client\nlittle choice of initial entry point into the Ethereum network. We would like to\nmaintain larger node lists containing hundreds of nodes, and update them\nregularly.")]),e._v(" "),n("p",[e._v("The scheme described here is a replacement for client bootstrap node lists with\nequivalent security and many additional benefits. Large lists populated by\ntraversing the node discovery DHT can serve as a fallback option for nodes which\ncan't join the DHT due to restrictive network policy. DNS-based node lists may\nalso be useful to Ethereum peering providers because their customers can\nconfigure the client to use the provider's list.")]),e._v(" "),n("h1",{attrs:{id:"specification"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),n("p",[e._v("A 'node list' is a list of 'node records' "),n("RouterLink",{attrs:{to:"/eip-778.html"}},[e._v("as defined by EIP-778")]),e._v("\nof arbitrary length. Lists\nmay refer to other lists using links. The entire list is signed using a\nsecp256k1 private key. The corresponding public key must be known to the client\nin order to verify the list.")],1),e._v(" "),n("p",[e._v("To refer to a DNS node list, clients use a URL with 'enrtree' scheme. The URL\ncontains the DNS name on which the list can be found as well as the public key\nthat signed the list. The public key is contained in the username part of the\nURL and is the base32 encoding of the compressed 32-byte binary public key.")]),e._v(" "),n("p",[e._v("Example:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("enrtree://AM5FCQLWIZX2QFPNJAP7VUERCCRNGRHWZG3YYHIUV7BVDQ5FDPRT2@nodes.example.org\n")])])]),n("p",[e._v("This URL refers to a node list at the DNS name 'nodes.example.org' and is signed\nby the public key\n"),n("code",[e._v("0x049f88229042fef9200246f49f94d9b77c4e954721442714e85850cb6d9e5daf2d880ea0e53cb3ac1a75f9923c2726a4f941f7d326781baa6380754a360de5c2b6")])]),e._v(" "),n("h2",{attrs:{id:"dns-record-structure"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dns-record-structure"}},[e._v("#")]),e._v(" DNS Record Structure")]),e._v(" "),n("p",[e._v("The nodes in a list are encoded as a merkle tree for distribution via the DNS\nprotocol. Entries of the merkle tree are contained in DNS TXT records. The root\nof the tree is a TXT record with the following content:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("enrtree-root:v1 e=<enr-root> l=<link-root> seq=<sequence-number> sig=<signature>\n")])])]),n("p",[e._v("where")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("enr-root")]),e._v(" and "),n("code",[e._v("link-root")]),e._v(" refer to the root hashes of subtrees containing\nnodes and links subtrees.")]),e._v(" "),n("li",[n("code",[e._v("sequence-number")]),e._v(" is the tree's update sequence number, a decimal integer.")]),e._v(" "),n("li",[n("code",[e._v("signature")]),e._v(" is a 65-byte secp256k1 EC signature over the keccak256 hash of the\nrecord content, excluding the "),n("code",[e._v("sig=")]),e._v(" part, encoded as URL-safe base64.")])]),e._v(" "),n("p",[e._v("Further TXT records on subdomains map hashes to one of three entry types. The\nsubdomain name of any entry is the base32 encoding of the (abbreviated)\nkeccak256 hash of its text content.")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("enrtree-branch:<h₁>,<h₂>,...,<hₙ>")]),e._v(" is an intermediate tree entry containing\nhashes of subtree entries.")]),e._v(" "),n("li",[n("code",[e._v("enrtree://<key>@<fqdn>")]),e._v(" is a leaf pointing to a different list located at\nanother fully qualified domain name. Note that this format matches the URL\nencoding. This type of entry may only appear in the subtree pointed to by\n"),n("code",[e._v("link-root")]),e._v(".")]),e._v(" "),n("li",[n("code",[e._v("enr:<node-record>")]),e._v(" is a leaf containing a node record. The node record is\nencoded as a URL-safe base64 string. Note that this type of entry matches the\ncanonical ENR text encoding. It may only appear in the "),n("code",[e._v("enr-root")]),e._v(" subtree.")])]),e._v(" "),n("p",[e._v("No particular ordering or structure is defined for the tree. Whenever the tree\nis updated, its sequence number should increase. The content of any TXT record\nshould be small enough to fit into the 512 byte limit imposed on UDP DNS\npackets. This limits the number of hashes that can be placed into an\n"),n("code",[e._v("enrtree-branch")]),e._v(" entry.")]),e._v(" "),n("p",[e._v("Example in zone file format:")]),e._v(" "),n("div",{staticClass:"language-text line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("; name                        ttl     class type  content\n@                             60      IN    TXT   enrtree-root:v1 e=JWXYDBPXYWG6FX3GMDIBFA6CJ4 l=C7HRFPF3BLGF3YR4DY5KX3SMBE seq=1 sig=o908WmNp7LibOfPsr4btQwatZJ5URBr2ZAuxvK4UWHlsB9sUOTJQaGAlLPVAhM__XJesCHxLISo94z5Z2a463gA\nC7HRFPF3BLGF3YR4DY5KX3SMBE    86900   IN    TXT   enrtree://AM5FCQLWIZX2QFPNJAP7VUERCCRNGRHWZG3YYHIUV7BVDQ5FDPRT2@morenodes.example.org\nJWXYDBPXYWG6FX3GMDIBFA6CJ4    86900   IN    TXT   enrtree-branch:2XS2367YHAXJFGLZHVAWLQD4ZY,H4FHT4B454P6UXFD7JCYQ5PWDY,MHTDO6TMUBRIA2XWG5LUDACK24\n2XS2367YHAXJFGLZHVAWLQD4ZY    86900   IN    TXT   enr:-HW4QOFzoVLaFJnNhbgMoDXPnOvcdVuj7pDpqRvh6BRDO68aVi5ZcjB3vzQRZH2IcLBGHzo8uUN3snqmgTiE56CH3AMBgmlkgnY0iXNlY3AyNTZrMaECC2_24YYkYHEgdzxlSNKQEnHhuNAbNlMlWJxrJxbAFvA\nH4FHT4B454P6UXFD7JCYQ5PWDY    86900   IN    TXT   enr:-HW4QAggRauloj2SDLtIHN1XBkvhFZ1vtf1raYQp9TBW2RD5EEawDzbtSmlXUfnaHcvwOizhVYLtr7e6vw7NAf6mTuoCgmlkgnY0iXNlY3AyNTZrMaECjrXI8TLNXU0f8cthpAMxEshUyQlK-AM0PW2wfrnacNI\nMHTDO6TMUBRIA2XWG5LUDACK24    86900   IN    TXT   enr:-HW4QLAYqmrwllBEnzWWs7I5Ev2IAs7x_dZlbYdRdMUx5EyKHDXp7AV5CkuPGUPdvbv1_Ms1CPfhcGCvSElSosZmyoqAgmlkgnY0iXNlY3AyNTZrMaECriawHKWdDRk2xeZkrOXBQ0dfMFLHY4eENZwdufn1S1o\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br")])]),n("h2",{attrs:{id:"client-protocol"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#client-protocol"}},[e._v("#")]),e._v(" Client Protocol")]),e._v(" "),n("p",[e._v('To find nodes at a given DNS name, say "mynodes.org":')]),e._v(" "),n("ol",[n("li",[e._v('Resolve the TXT record of the name and check whether it contains a valid\n"enrtree-root=v1" entry. Let\'s say the '),n("code",[e._v("enr-root")]),e._v(' hash contained in the entry\nis "CFZUWDU7JNQR4VTCZVOJZ5ROV4".')]),e._v(" "),n("li",[e._v("Verify the signature on the root against the known public key and check\nwhether the sequence number is larger than or equal to any previous number\nseen for that name.")]),e._v(" "),n("li",[e._v('Resolve the TXT record of the hash subdomain, e.g.\n"CFZUWDU7JNQR4VTCZVOJZ5ROV4.mynodes.org" and verify whether the content\nmatches the hash.')]),e._v(" "),n("li",[e._v("The next step depends on the entry type found:\n"),n("ul",[n("li",[e._v("for "),n("code",[e._v("enrtree-branch")]),e._v(": parse the list of hashes and continue resolving them (step 3).")]),e._v(" "),n("li",[e._v("for "),n("code",[e._v("enr")]),e._v(": decode, verify the node record and import it to local node storage.")])])])]),e._v(" "),n("p",[e._v("During traversal, the client must track hashes and domains which are already\nresolved to avoid going into an infinite loop. It's in the client's best\ninterest to traverse the tree in random order.")]),e._v(" "),n("p",[e._v("Client implementations should avoid downloading the entire tree at once during\nnormal operation. It's much better to request entries via DNS when-needed, i.e.\nat the time when the client is looking for peers.")]),e._v(" "),n("h1",{attrs:{id:"rationale"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),n("h3",{attrs:{id:"why-dns"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#why-dns"}},[e._v("#")]),e._v(" Why DNS?")]),e._v(" "),n("p",[e._v("We have chosen DNS as the distribution medium because it is always available,\neven under restrictive network conditions. The protocol provides low latency and\nanswers to DNS queries can be cached by intermediate resolvers. No custom server\nsoftware is needed. Node lists can be deployed to any DNS provider such as\nCloudFlare DNS, dnsimple, Amazon Route 53 using their respective client\nlibraries.")]),e._v(" "),n("h3",{attrs:{id:"why-is-this-a-merkle-tree"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#why-is-this-a-merkle-tree"}},[e._v("#")]),e._v(" Why is this a merkle tree?")]),e._v(" "),n("p",[e._v("Being a merkle tree, any node list can be authenticated by a single signature on\nthe root. Hash subdomains protect the integrity of the list. At worst\nintermediate resolvers can block access to the list or disallow updates to it,\nbut cannot corrupt its content. The sequence number prevents replacing the root\nwith an older version.")]),e._v(" "),n("p",[e._v("Synchronizing updates on the client side can be done incrementally, which\nmatters for large lists. Individual entries of the tree are small enough to fit\ninto a single UDP packet, ensuring compatibility with environments where only\nbasic UDP DNS is available. The tree format also works well with caching\nresolvers: only the root of the tree needs a short TTL. Intermediate entries and\nleaves can be cached for days.")]),e._v(" "),n("h3",{attrs:{id:"why-does-the-link-subtree-exist"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#why-does-the-link-subtree-exist"}},[e._v("#")]),e._v(" Why does the link subtree exist?")]),e._v(" "),n("p",[e._v("Links between lists enable federation and web-of-trust functionality. The\noperator of a large list can delegate maintenance to other list providers. If\ntwo node lists link to each other, users can use either list and get nodes from\nboth.")]),e._v(" "),n("p",[e._v("The link subtree is separate from the tree containing ENRs. This is done to\nenable client implementations to sync these trees independently. A client\nwanting to get as many nodes as possible will sync the link tree first and add\nall linked names to the sync horizon.")]),e._v(" "),n("h1",{attrs:{id:"references"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),n("ol",[n("li",[e._v("The base64 and base32 encodings used to represent binary data are defined in\n"),n("a",{attrs:{href:"https://tools.ietf.org/html/rfc4648",target:"_blank",rel:"noopener noreferrer"}},[e._v("RFC 4648"),n("OutboundLink")],1),e._v(". No padding is used for base64\nand base32 data.")])]),e._v(" "),n("h1",{attrs:{id:"copyright"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),n("p",[e._v("Copyright and related rights waived via "),n("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),n("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=a.exports}}]);