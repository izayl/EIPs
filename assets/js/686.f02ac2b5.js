(window.webpackJsonp=window.webpackJsonp||[]).push([[686],{1108:function(e,t,a){"use strict";a.r(t);var s=a(46),o=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),a("p",[e._v("Add a new opcode, "),a("code",[e._v("IMPERSONATECALL")]),e._v(" at "),a("code",[e._v("0xf6")]),e._v(", which is similar in idea to "),a("code",[e._v("CALL (0xF1)")]),e._v(", except that it impersonates a sender, i.e. the callee sees a sender different from the real caller. The impersonated sender address is derived from the real caller address and a salt.")]),e._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),a("p",[e._v("This proposal enables native multi-user wallets (wallets that serve multiple users) that can be commanded by EIP-712 based messages and therefore enable meta-transactions. Multi-user wallets also enable the aggregation of transfer operations in batches similar to rollups, but maintaining the same address space as normal onchain transactions, so the sender's wallet does not need to be upgraded to support sinding ether or tokens to a user of a multi-user wallet. Additionally, many times a sponsor company wants to deploy non-custodial smart wallets for all its users. The sponsor does not want to pay the deployment cost of each user contract in advance. Counterfactual contract creation enables this, yet it forces the sponsor to create the smart wallet (or a proxy contract to it) when the user wants to transfer ether or tokens out of his/her account for the first time. This proposal avoids this extra cost, which is at least 42000 gas per user.")]),e._v(" "),a("h2",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),a("p",[a("code",[e._v("IMPERSONATECALL")]),e._v(": "),a("code",[e._v("0xf6")]),e._v(", takes 7 operands:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("gas")]),e._v(": the amount of gas the code may use in order to execute;")]),e._v(" "),a("li",[a("code",[e._v("to")]),e._v(": the destination address whose code is to be executed;")]),e._v(" "),a("li",[a("code",[e._v("in_offset")]),e._v(": the offset into memory of the input;")]),e._v(" "),a("li",[a("code",[e._v("in_size")]),e._v(": the size of the input in bytes;")]),e._v(" "),a("li",[a("code",[e._v("ret_offset")]),e._v(": the offset into memory of the output;")]),e._v(" "),a("li",[a("code",[e._v("ret_size")]),e._v(": the size of the scratch pad for the output.")]),e._v(" "),a("li",[a("code",[e._v("salt")]),e._v(" is a "),a("code",[e._v("32")]),e._v(" bytes value (a stack item).")])]),e._v(" "),a("h3",{attrs:{id:"computation-of-impersonated-sender"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computation-of-impersonated-sender"}},[e._v("#")]),e._v(" Computation of impersonated sender")]),e._v(" "),a("p",[e._v("The impersonated sender address is computed as "),a("code",[e._v("keccak256( 0xff ++ address ++ salt ++ zeros32)[12:]")]),e._v(".")]),e._v(" "),a("ul",[a("li",[a("p",[a("code",[e._v("0xff")]),e._v(" is a single byte,")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("address")]),e._v(" is always "),a("code",[e._v("20")]),e._v(" bytes, and represents the address of the real caller contract.")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("salt")]),e._v(" is always "),a("code",[e._v("32")]),e._v(" bytes.")])]),e._v(" "),a("li",[a("p",[e._v("The field zeros32 corresponds to 32 zero bytes.")])])]),e._v(" "),a("p",[e._v("This scheme emulates "),a("code",[e._v("CREATE2")]),e._v(" address derivation, but it cannot practically collude with the "),a("code",[e._v("CREATE2")]),e._v(" address space.")]),e._v(" "),a("h3",{attrs:{id:"notes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#notes"}},[e._v("#")]),e._v(" Notes")]),e._v(" "),a("ul",[a("li",[e._v("The opcode behaves exactly as "),a("code",[e._v("CALL")]),e._v(" in terms of gas consumption.")]),e._v(" "),a("li",[e._v("In the called context "),a("code",[e._v("CALLER (0x33)")]),e._v(" returns the impersonated address.")]),e._v(" "),a("li",[e._v("If value transfer is non-zero in the call, the value is transferred from the impersonated account, and not from the real caller. This can be used to transfer ether out of an impersonated account.")])]),e._v(" "),a("h2",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),a("p",[e._v("Even if "),a("code",[e._v("IMPERSONATECALL")]),e._v(" requires hashing 3 words, implying an additional cost of 180 gas, we think the benefit of accounting for hashing doesn't not compensate increasing the complexity of the implementation.")]),e._v(" "),a("p",[e._v("We use the zeros32 field to base address derivation in a pre-image of similar size than CREATE2 and reuse the existing address derivation functions. We also avoid worrying about address collisions between EOA derivation (65 bytes pre-image), CREATE derivation (from 23 to 27 bytes pre-image, for a 32bit nonce) and CREATE2 derivation (85 bytes pre-image).")]),e._v(" "),a("p",[e._v("An option is to omit the zeros32 field: the resulting length of the Keccak pre-image for IMPERSONATECALL address is 53 bytes , which does not generate address collision.")]),e._v(" "),a("p",[e._v("While the same functionality could be provided in a pre-compiled contract, we believe using a new opcode is a cleaner solution.")]),e._v(" "),a("h2",{attrs:{id:"clarifications"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#clarifications"}},[e._v("#")]),e._v(" Clarifications")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("This EIP makes address collisions possible, yet practically impossible.")])]),e._v(" "),a("li",[a("p",[e._v("If a contract already exists with an impersonated address, the "),a("code",[e._v("IMPERSONATECALL")]),e._v(" is executed in the same way, and the existing code will not be executed. It should  be noted that "),a("code",[e._v("SELFDESTRUCT")]),e._v(" ("),a("code",[e._v("0xff")]),e._v(") cannot be executed directly with "),a("code",[e._v("IMPERSONATECALL")]),e._v(" as no opcode is executed in the context of the impersonated account.")])])]),e._v(" "),a("h2",{attrs:{id:"backward-compatibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backward-compatibility"}},[e._v("#")]),e._v(" Backward Compatibility")]),e._v(" "),a("p",[e._v("The opcode number  "),a("code",[e._v("0xf6")]),e._v(" is currently unused and results in an out-of-gas (OOG) exception.  Solidity uses the "),a("code",[e._v("INVALID (0xfe)")]),e._v(" opcode (called "),a("code",[e._v("ABORT")]),e._v(" by EIP-1803) to raise OOG exceptions, so the  "),a("code",[e._v("0xf6")]),e._v(" opcode does not appear in normal Solidity programs. Programmers are already advised not to include this opcode in contracts written in EVM assembly.  Therefore is does not pose any backward compatibility risk.")]),e._v(" "),a("h2",{attrs:{id:"test-cases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test-cases"}},[e._v("#")]),e._v(" Test Cases")]),e._v(" "),a("p",[e._v("We present 4 examples of impersonated address derivation:")]),e._v(" "),a("p",[e._v("Example 0")]),e._v(" "),a("ul",[a("li",[e._v("address "),a("code",[e._v("0x0000000000000000000000000000000000000000")])]),e._v(" "),a("li",[e._v("salt "),a("code",[e._v("0x0000000000000000000000000000000000000000000000000000000000000000")])]),e._v(" "),a("li",[e._v("result: "),a("code",[e._v("0xFFC4F52F884A02BCD5716744CD622127366F2EDF")])])]),e._v(" "),a("p",[e._v("Example 1")]),e._v(" "),a("ul",[a("li",[e._v("address "),a("code",[e._v("0xdeadbeef00000000000000000000000000000000")])]),e._v(" "),a("li",[e._v("salt "),a("code",[e._v("0x0000000000000000000000000000000000000000000000000000000000000000")])]),e._v(" "),a("li",[e._v("result: "),a("code",[e._v("0x85F15E045E1244AC03289B48448249DC0A34AA30")])])]),e._v(" "),a("p",[e._v("Example 2")]),e._v(" "),a("ul",[a("li",[e._v("address "),a("code",[e._v("0xdeadbeef00000000000000000000000000000000")])]),e._v(" "),a("li",[e._v("salt "),a("code",[e._v("0x000000000000000000000000feed000000000000000000000000000000000000")])]),e._v(" "),a("li",[e._v("result: "),a("code",[e._v("0x2DB27D1D6BE32C9ABFA484BA3D591101881D4B9F")])])]),e._v(" "),a("p",[e._v("Example 3")]),e._v(" "),a("ul",[a("li",[e._v("address "),a("code",[e._v("0x00000000000000000000000000000000deadbeef")])]),e._v(" "),a("li",[e._v("salt "),a("code",[e._v("0x00000000000000000000000000000000000000000000000000000000cafebabe")])]),e._v(" "),a("li",[e._v("result: "),a("code",[e._v("0x5004E448F43EFE3C7BF32F94B83B843D03901457")])])]),e._v(" "),a("h2",{attrs:{id:"security-considerations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#security-considerations"}},[e._v("#")]),e._v(" Security Considerations")]),e._v(" "),a("p",[e._v("The address derivation scheme prevents address collision with another deployed contract or an externally owned account, as the impersonated sender address is derived from the real caller address and a salt.")]),e._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),a("p",[e._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),a("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=o.exports}}]);