(window.webpackJsonp=window.webpackJsonp||[]).push([[748],{1175:function(t,s,e){"use strict";e.r(s);var a=e(46),n=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"abstract"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[t._v("#")]),t._v(" Abstract")]),t._v(" "),e("p",[t._v("Introduce a section in the EOF format ("),e("RouterLink",{attrs:{to:"/zh/eip-3540.html"}},[t._v("EIP-3540")]),t._v(") for storing the list of "),e("code",[t._v("JUMPDEST")]),t._v("s, validate the correctness of this list at the time of contract creation, and remove the need for "),e("code",[t._v("JUMPDEST")]),t._v("-analysis at execution time. In EOF contracts, the "),e("code",[t._v("JUMPDEST")]),t._v(" instruction is not needed anymore and becomes invalid. Legacy contracts are entirely unaffected by this change.")],1),t._v(" "),e("h2",{attrs:{id:"motivation"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[t._v("#")]),t._v(" Motivation")]),t._v(" "),e("p",[t._v("Currently existing contracts require no validation of correctness, but every time they are executed, a list must be built containing all the valid jump-destinations. This is an overhead which can be avoided, albeit the effect of the overhead depends on the client implementation.")]),t._v(" "),e("p",[t._v("With the structure provided by EIP-3540 it is easy to store and transmit a table of valid jump-destinations instead of using designated "),e("code",[t._v("JUMPDEST")]),t._v(" (0x5b) opcodes in the code.")]),t._v(" "),e("p",[t._v("The goal of this change is that we trade less complexity (and processing time) at execution time for more complexity at contract creation time. Through benchmarks we have identified that the mandatory execution preparation time is the same as before for extreme cases (i.e. deliberate edge cases), while it is ~10x faster for the average case.")]),t._v(" "),e("p",[t._v('Finally, this change puts an implicit bound on "initcode analysis" which is now limited to jumpdests section loading of max size of 0xffff. The legacy code remains vulnerable.')]),t._v(" "),e("h2",{attrs:{id:"specification"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[t._v("#")]),t._v(" Specification")]),t._v(" "),e("p",[t._v("This feature is introduced on the very same block "),e("RouterLink",{attrs:{to:"/zh/eip-3540.html"}},[t._v("EIP-3540")]),t._v(" is enabled, therefore every EOF1-compatible bytecode MUST have a JUMPDEST-table if it uses jumps.")],1),t._v(" "),e("p",[e("em",[t._v("Remark:")]),t._v(" We rely on the notation of "),e("em",[t._v("initcode")]),t._v(", "),e("em",[t._v("code")]),t._v(" and "),e("em",[t._v("creation")]),t._v(" as defined by "),e("RouterLink",{attrs:{to:"/zh/eip-3540.html"}},[t._v("EIP-3540")]),t._v(", and extend validation rules of "),e("RouterLink",{attrs:{to:"/zh/eip-3670.html"}},[t._v("EIP-3670")]),t._v(".")],1),t._v(" "),e("h3",{attrs:{id:"eof-container-changes"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#eof-container-changes"}},[t._v("#")]),t._v(" EOF container changes")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("A new EOF section called "),e("code",[t._v("jumpdests")]),t._v(" ("),e("code",[t._v("section_kind = 3")]),t._v(") is introduced. It contains a sequence of "),e("em",[t._v("n")]),t._v(" unsigned integers "),e("em",[t._v("jumploc"),e("sub",[t._v("i")])]),t._v(".")])]),t._v(" "),e("li",[e("p",[t._v("The "),e("em",[t._v("jumploc"),e("sub",[t._v("i")])]),t._v(" values are encoded with "),e("a",{attrs:{href:"https://en.wikipedia.org/wiki/LEB128#Unsigned_LEB128",target:"_blank",rel:"noopener noreferrer"}},[t._v("unsigned LEB128"),e("OutboundLink")],1),t._v(".")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("description")]),t._v(" "),e("th",[t._v("encoding")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("jumploc"),e("sub",[t._v("0")])]),t._v(" "),e("td",[t._v("unsigned LEB128")])]),t._v(" "),e("tr",[e("td",[t._v("jumploc"),e("sub",[t._v("1")])]),t._v(" "),e("td",[t._v("unsigned LEB128")])]),t._v(" "),e("tr",[e("td",[t._v("...")]),t._v(" "),e("td")]),t._v(" "),e("tr",[e("td",[t._v("jumploc"),e("sub",[t._v("n")])]),t._v(" "),e("td",[t._v("unsigned LEB128")])])])])]),t._v(" "),e("li",[e("p",[t._v("The jump destinations represent the set of valid code positions as arguments to jump instructions. They are delta-encoded therefore partial sum must be performed to retrieve the absolute offsets.")]),t._v(" "),e("div",{staticClass:"language-python line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-python"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("jumpdest")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" jumpdests_table"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("list")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("sum")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("jumpdests_table"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("n"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br")])])])]),t._v(" "),e("h3",{attrs:{id:"validation-rules"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#validation-rules"}},[t._v("#")]),t._v(" Validation rules")]),t._v(" "),e("blockquote",[e("p",[t._v("This section extends contact creation validation rules (as defined in EIP-3540).")])]),t._v(" "),e("ol",{attrs:{start:"4"}},[e("li",[t._v("The "),e("code",[t._v("jumpdests")]),t._v(" section MUST be present if and only if the "),e("code",[t._v("code")]),t._v(" section contains "),e("code",[t._v("JUMP")]),t._v(" or "),e("code",[t._v("JUMPI")]),t._v(" opcodes.")]),t._v(" "),e("li",[t._v("If the "),e("code",[t._v("jumpdests")]),t._v(" section is present it MUST directly precede the "),e("code",[t._v("code")]),t._v(" section. In this case a valid EOF bytecode will have the form of "),e("code",[t._v("format, magic, version, [jumpdests_section_header], code_section_header, [data_section_header], 0, [jumpdests_section_contents], code_section_contents, [data_section_contents]")]),t._v(".")]),t._v(" "),e("li",[t._v("The LEB128 encoding of a "),e("code",[t._v("jumploc")]),t._v(" must be valid: the encoding must be complete and not read out of "),e("code",[t._v("jumpdests")]),t._v(" section. As an additional constraint, the shortest possible encoding must be used.")]),t._v(" "),e("li",[t._v("With an exception of the first entry, the value of "),e("code",[t._v("jumploc")]),t._v(" MUST NOT be 0.")]),t._v(" "),e("li",[t._v("Every "),e("code",[t._v("jumploc")]),t._v(" MUST point to a valid opcode. They MUST NOT point into PUSH-data or outside of the code section.")]),t._v(" "),e("li",[t._v("The "),e("code",[t._v("JUMPDEST")]),t._v(" (0x5b) instruction becomes undefined (Note: According to rules of EIP-3670, deploying the code will fail if it contains "),e("code",[t._v("JUMPDEST")]),t._v(")")])]),t._v(" "),e("h3",{attrs:{id:"execution"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#execution"}},[t._v("#")]),t._v(" Execution")]),t._v(" "),e("ol",{attrs:{start:"10"}},[e("li",[t._v("When executing "),e("code",[t._v("JUMP")]),t._v(" or "),e("code",[t._v("JUMPI")]),t._v(" instructions, the jump destination MUST be in the "),e("code",[t._v("jumpdests")]),t._v(" table. Otherwise, the execution aborts with "),e("em",[t._v("bad jump destination")]),t._v(". In case of "),e("code",[t._v("JUMPI")]),t._v(", the check is done only when the jump is to be taken (no change to the previous behaviour).")])]),t._v(" "),e("h2",{attrs:{id:"rationale"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[t._v("#")]),t._v(" Rationale")]),t._v(" "),e("h3",{attrs:{id:"jumpdests-section-is-bounded"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jumpdests-section-is-bounded"}},[t._v("#")]),t._v(" Jumpdests section is bounded")]),t._v(" "),e("p",[t._v("The length of the "),e("code",[t._v("jumpdests")]),t._v(" section is bounded by the EOF maximum section size value 0xffff. Moreover, for deployed code this additionally limited by the max bytecode size 0x6000. Then any valid "),e("code",[t._v("jumpdests")]),t._v(" section may not be more larger than 0x3000.")]),t._v(" "),e("h3",{attrs:{id:"delta-encoding"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#delta-encoding"}},[t._v("#")]),t._v(" Delta encoding")]),t._v(" "),e("p",[t._v("Delta-encoding is very efficient for this job. From a quick analysis of a small set of contracts "),e("code",[t._v("JUMPDEST")]),t._v(" opcodes are relatively close to each other. In the delta-encoding the values almost never exceed 128. Combined with any form of variable-length quantity (VLQ) where values < 128 occupy one byte, encoding of single jumpdest takes ~1 byte. We also remove "),e("code",[t._v("JUMPDEST")]),t._v(" opcodes from the code section therefore the total bytecode length remains the same if extreme examples are ignored.")]),t._v(" "),e("p",[t._v("By extreme examples we mean contracts having a distance between two subsequent JUMPDESTs larger than 128. Then the LEB128 encoding of such distance requires more than one byte and the total bytecode size will increase by the additional number of bytes used.")]),t._v(" "),e("h3",{attrs:{id:"leb128-for-offsets"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#leb128-for-offsets"}},[t._v("#")]),t._v(" LEB128 for offsets")]),t._v(" "),e("p",[t._v("The LEB128 encoding is the most popular VLQ used in DWARF and WebAssembly.")]),t._v(" "),e("p",[t._v("LEB128 allows encoding a fixed value with arbitrary number of bytes by having zero payloads for most significant bits of the value. To ensure there exists only single encoding of a given value, we additionally require the shortest possible LEB128 encoding to be used. This constraint is also required by WebAssembly.")]),t._v(" "),e("h3",{attrs:{id:"size-prefix-for-offsets"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#size-prefix-for-offsets"}},[t._v("#")]),t._v(" Size-prefix for offsets")]),t._v(" "),e("p",[t._v("This is another option for encoding inspired by UTF-8. The benefit is that the number of following bytes is encoded in the first byte (the top two bits), so the expected length is known upfront.")]),t._v(" "),e("p",[t._v("A simple decoder is the following:")]),t._v(" "),e("div",{staticClass:"language-python line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-python"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("decode")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("input")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("bytes")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    size_prefix "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("input")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" size_prefix "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("input")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x3f")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("elif")]),t._v(" size_prefix "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("input")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x3f")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("input")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("elif")]),t._v(" size_prefix "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("input")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x3f")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("16")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("input")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("input")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Do not support case 3")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("assert")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("False")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br")])]),e("h3",{attrs:{id:"empty-table"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#empty-table"}},[t._v("#")]),t._v(" Empty table")]),t._v(" "),e("p",[t._v("In case code does not use jumps, an empty JUMPDEST table is represented by omitting "),e("code",[t._v("jumpdests")]),t._v(" section as opposed to a section that is always present, but allowed to be empty. This is consistent with the requirement of EIP-3540 for section size to be non-zero. Additionally, omitting the section saves 3 bytes of code storage.")]),t._v(" "),e("h3",{attrs:{id:"why-jumpdests-before-code"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#why-jumpdests-before-code"}},[t._v("#")]),t._v(" Why jumpdests before code?")]),t._v(" "),e("p",[t._v("The contents of "),e("code",[t._v("jumpdests")]),t._v(" section are always needed to start EVM execution. For chunked and/or merkleized bytecode it is more efficient to have "),e("code",[t._v("jumpdests")]),t._v(" just after the EOF header so they can share the same first chunk(s).")]),t._v(" "),e("h3",{attrs:{id:"code-chunking-merkleization"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#code-chunking-merkleization"}},[t._v("#")]),t._v(" Code chunking / merkleization")]),t._v(" "),e("p",[t._v('In code chunking the contract code is split into (fixed size) chunks. Due to the requirement of jumpdest-analysis, it must be known where the first instruction starts in a given chunk, in case the split happened within a PUSH-data. This is commonly accomplished with reserving the first byte of the chunk as the "first instruction offset" (FIO) field.')]),t._v(" "),e("p",[t._v("With this EIP, code chunking does not need to have such a field. However, the jumpdest table must be provided instead (for all the chunks up until the last jump location used during execution).")]),t._v(" "),e("h3",{attrs:{id:"benchmarks-performance-analysis"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#benchmarks-performance-analysis"}},[t._v("#")]),t._v(" Benchmarks / performance analysis")]),t._v(" "),e("p",[t._v("We compared the performance of "),e("code",[t._v("jumpdests")]),t._v(" section loading to JUMPDEST analysis in evmone/Baseline interpreter. In both cases a bitset of valid jumpdest positions is built.")]),t._v(" "),e("p",[t._v("We used the worst case for "),e("code",[t._v("jumpdests")]),t._v(" section as the benchmark baseline. This is the case where every position in the code section is valid jumpdest. I.e. the bytecode has as many jumpdests as possible making the jumpdests section as large as possible. The encoded representation is "),e("code",[t._v("0x00, 0x01, 0x01, 0x01, ...")]),t._v(".")]),t._v(" "),e("p",[t._v("This also happen to be the worst case for the JUMPDEST analysis.")]),t._v(" "),e("p",[t._v("Further, we picked 5 popular contracts from the Ethereum mainnet.")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("case")]),t._v(" "),e("th",[t._v("size")]),t._v(" "),e("th",[t._v("num JUMPDESTs")]),t._v(" "),e("th",[t._v("JUMPDEST analysis (cycles/byte)")]),t._v(" "),e("th",[t._v("jumpdests load (cycles/byte)")]),t._v(" "),e("th",[t._v("performance change")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("worst")]),t._v(" "),e("td",[t._v("65535")]),t._v(" "),e("td",[t._v("65535")]),t._v(" "),e("td",[t._v("9.11")]),t._v(" "),e("td",[t._v("9.36")]),t._v(" "),e("td",[t._v("2.75%")])]),t._v(" "),e("tr",[e("td",[t._v("RoninBridge")]),t._v(" "),e("td",[t._v("1760")]),t._v(" "),e("td",[t._v("71")]),t._v(" "),e("td",[t._v("3.57")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("-89.41%")])]),t._v(" "),e("tr",[e("td",[t._v("UniswapV2ERC20")]),t._v(" "),e("td",[t._v("2319")]),t._v(" "),e("td",[t._v("61")]),t._v(" "),e("td",[t._v("2.10")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("-88.28%")])]),t._v(" "),e("tr",[e("td",[t._v("DepositContract")]),t._v(" "),e("td",[t._v("6358")]),t._v(" "),e("td",[t._v("123")]),t._v(" "),e("td",[t._v("1.86")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("-90.24%")])]),t._v(" "),e("tr",[e("td",[t._v("TetherToken")]),t._v(" "),e("td",[t._v("11075")]),t._v(" "),e("td",[t._v("236")]),t._v(" "),e("td",[t._v("1.91")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("-89.58%")])]),t._v(" "),e("tr",[e("td",[t._v("UniswapV2Router02")]),t._v(" "),e("td",[t._v("21943")]),t._v(" "),e("td",[t._v("468")]),t._v(" "),e("td",[t._v("2.26")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("-91.17%")])])])]),t._v(" "),e("p",[t._v("For the worst case the performance difference between JUMPDEST analysis and jumpdests section loading is very small. The performance very slow compared to memory copy (0.15 cycles/byte).")]),t._v(" "),e("p",[t._v("However, the maximum length for the worst cases is different. For JUMPDEST analysis this is 24576 (0x6000) for deployed contracts and only limited by EVM memory cost in case of "),e("em",[t._v("initcode")]),t._v(" (can be over 1MB). For jumpdests sections, the limit is 12288 for deployed contracts (the deployed bytecode length limit must be split equally between jumpdests and code sections). For "),e("em",[t._v("initcode")]),t._v(" case, the limit is 65535 because this is the maximum section size allowed by EOF.")]),t._v(" "),e("p",[t._v('For "popular" contracts the gained efficiency is ~10x because the jumpdests section is relatively small compared to the code section and therefore there is much less bytes to loop over than in JUMPDEST analysis.')]),t._v(" "),e("h2",{attrs:{id:"reference-implementation"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reference-implementation"}},[t._v("#")]),t._v(" Reference Implementation")]),t._v(" "),e("p",[t._v("We extend the "),e("code",[t._v("validate_code()")]),t._v(" function of "),e("RouterLink",{attrs:{to:"/zh/eip-3670.html"}},[t._v("EIP-3670")]),t._v(":")],1),t._v(" "),e("div",{staticClass:"language-python line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-python"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The same table as in EIP-3670")]),t._v("\nvalid_opcodes "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Remove JUMPDEST from the list of valid opcodes")]),t._v("\nvalid_opcodes"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("remove"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x5b")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# This helper decodes a single unsigned LEB128 encoded value")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# This will abort on truncated (short) input")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("leb128u_decode")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("input")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("bytes")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  ret "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n  shift "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n  consumed_bytes "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("True")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Check for truncated input")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("assert")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("consumed_bytes "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("len")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("input")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Only allow up to 4-byte long leb128 encodings")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("assert")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("consumed_bytes "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n      input_byte "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("input")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("consumed_bytes"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n      consumed_bytes "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n      ret "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("input_byte "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x7f")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" shift\n      "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("input_byte "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x80")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n          "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Do not allow additional leading zero bits.")]),t._v("\n          "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("assert")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("input_byte "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" consumed_bytes "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n          "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),t._v("\n      shift "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ret"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" consumed_bytes"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# This helper parses the jumpdest table into a list of relative offsets")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# This will abort on truncated (short) input")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("parse_table")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("input")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("bytes")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("list")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  jumpdests "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  pos "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" pos "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("len")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("input")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      value"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" consumed_bytes "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" leb128u_decode"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("input")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("pos"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n      jumpdests"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("append"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("value"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n      pos "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" consumed_bytes\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" jumpdests\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# This helper translates the delta offsets into absolute ones")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# This will abort on invalid 0-value entries")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("process_jumpdests")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("delta"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("list")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("list")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    jumpdests "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    partial_sum "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n    first "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("True")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" d "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" delta"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" first"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            first "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("False")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("assert")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("d "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        partial_sum "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" d\n        jumpdests"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("append"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("partial_sum"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" jumpdests\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Fails with assertion on invalid code")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Expects list of absolute jumpdest offsets")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("validate_code")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("code"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("bytes")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" jumpdests"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("list")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    pos "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" pos "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("len")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("code"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Ensure the opcode is valid")]),t._v("\n        opcode "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" code"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("pos"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n        pos "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("assert")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("opcode "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" valid_opcodes"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Remove touched offset")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            jumpdests"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("remove"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pos"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("except")]),t._v(" ValueError"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pass")]),t._v("\n\n        "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Skip pushdata")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" opcode "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x60")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("and")]),t._v(" opcode "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x7f")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            pos "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" opcode "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x60")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Ensure last PUSH doesn't go over code end")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("assert")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pos "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("len")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("code"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The table is invalid if there are untouched locations")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("assert")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("len")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("jumpdests"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br"),e("span",{staticClass:"line-number"},[t._v("15")]),e("br"),e("span",{staticClass:"line-number"},[t._v("16")]),e("br"),e("span",{staticClass:"line-number"},[t._v("17")]),e("br"),e("span",{staticClass:"line-number"},[t._v("18")]),e("br"),e("span",{staticClass:"line-number"},[t._v("19")]),e("br"),e("span",{staticClass:"line-number"},[t._v("20")]),e("br"),e("span",{staticClass:"line-number"},[t._v("21")]),e("br"),e("span",{staticClass:"line-number"},[t._v("22")]),e("br"),e("span",{staticClass:"line-number"},[t._v("23")]),e("br"),e("span",{staticClass:"line-number"},[t._v("24")]),e("br"),e("span",{staticClass:"line-number"},[t._v("25")]),e("br"),e("span",{staticClass:"line-number"},[t._v("26")]),e("br"),e("span",{staticClass:"line-number"},[t._v("27")]),e("br"),e("span",{staticClass:"line-number"},[t._v("28")]),e("br"),e("span",{staticClass:"line-number"},[t._v("29")]),e("br"),e("span",{staticClass:"line-number"},[t._v("30")]),e("br"),e("span",{staticClass:"line-number"},[t._v("31")]),e("br"),e("span",{staticClass:"line-number"},[t._v("32")]),e("br"),e("span",{staticClass:"line-number"},[t._v("33")]),e("br"),e("span",{staticClass:"line-number"},[t._v("34")]),e("br"),e("span",{staticClass:"line-number"},[t._v("35")]),e("br"),e("span",{staticClass:"line-number"},[t._v("36")]),e("br"),e("span",{staticClass:"line-number"},[t._v("37")]),e("br"),e("span",{staticClass:"line-number"},[t._v("38")]),e("br"),e("span",{staticClass:"line-number"},[t._v("39")]),e("br"),e("span",{staticClass:"line-number"},[t._v("40")]),e("br"),e("span",{staticClass:"line-number"},[t._v("41")]),e("br"),e("span",{staticClass:"line-number"},[t._v("42")]),e("br"),e("span",{staticClass:"line-number"},[t._v("43")]),e("br"),e("span",{staticClass:"line-number"},[t._v("44")]),e("br"),e("span",{staticClass:"line-number"},[t._v("45")]),e("br"),e("span",{staticClass:"line-number"},[t._v("46")]),e("br"),e("span",{staticClass:"line-number"},[t._v("47")]),e("br"),e("span",{staticClass:"line-number"},[t._v("48")]),e("br"),e("span",{staticClass:"line-number"},[t._v("49")]),e("br"),e("span",{staticClass:"line-number"},[t._v("50")]),e("br"),e("span",{staticClass:"line-number"},[t._v("51")]),e("br"),e("span",{staticClass:"line-number"},[t._v("52")]),e("br"),e("span",{staticClass:"line-number"},[t._v("53")]),e("br"),e("span",{staticClass:"line-number"},[t._v("54")]),e("br"),e("span",{staticClass:"line-number"},[t._v("55")]),e("br"),e("span",{staticClass:"line-number"},[t._v("56")]),e("br"),e("span",{staticClass:"line-number"},[t._v("57")]),e("br"),e("span",{staticClass:"line-number"},[t._v("58")]),e("br"),e("span",{staticClass:"line-number"},[t._v("59")]),e("br"),e("span",{staticClass:"line-number"},[t._v("60")]),e("br"),e("span",{staticClass:"line-number"},[t._v("61")]),e("br"),e("span",{staticClass:"line-number"},[t._v("62")]),e("br"),e("span",{staticClass:"line-number"},[t._v("63")]),e("br"),e("span",{staticClass:"line-number"},[t._v("64")]),e("br"),e("span",{staticClass:"line-number"},[t._v("65")]),e("br"),e("span",{staticClass:"line-number"},[t._v("66")]),e("br"),e("span",{staticClass:"line-number"},[t._v("67")]),e("br"),e("span",{staticClass:"line-number"},[t._v("68")]),e("br"),e("span",{staticClass:"line-number"},[t._v("69")]),e("br"),e("span",{staticClass:"line-number"},[t._v("70")]),e("br"),e("span",{staticClass:"line-number"},[t._v("71")]),e("br"),e("span",{staticClass:"line-number"},[t._v("72")]),e("br"),e("span",{staticClass:"line-number"},[t._v("73")]),e("br"),e("span",{staticClass:"line-number"},[t._v("74")]),e("br"),e("span",{staticClass:"line-number"},[t._v("75")]),e("br"),e("span",{staticClass:"line-number"},[t._v("76")]),e("br"),e("span",{staticClass:"line-number"},[t._v("77")]),e("br"),e("span",{staticClass:"line-number"},[t._v("78")]),e("br")])]),e("h2",{attrs:{id:"test-cases"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#test-cases"}},[t._v("#")]),t._v(" Test Cases")]),t._v(" "),e("h4",{attrs:{id:"valid-bytecodes"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#valid-bytecodes"}},[t._v("#")]),t._v(" Valid bytecodes")]),t._v(" "),e("ul",[e("li",[t._v("No jumpdests")]),t._v(" "),e("li",[t._v("Every byte is a jumpdest")]),t._v(" "),e("li",[t._v("Distant jumpdests (0x7f and 0x3f01 bytes apart)")]),t._v(" "),e("li",[t._v("Max number of jumpdests\n"),e("ul",[e("li",[t._v("1-byte offset encoding: initcode of max size (64K) with jumpdest at each byte - table contains 65536 1-byte offsets, first one is 0x00, all others equal 0x01")]),t._v(" "),e("li",[t._v("2-byte offset encoding: inicode of max size with jumpdests 0x80 (128) bytes apart - table contains 512 offsets, first one is 0x7f (127), all others equal 0x8001")]),t._v(" "),e("li",[t._v("3-byte offset encoding: inicode of max size with jumpdests 0x4000 (16384) bytes apart - table contains 4 offsets: 0xFF7F (16383), 0x808001, 0x808001, 0x808001")])])])]),t._v(" "),e("h4",{attrs:{id:"invalid-bytecodes"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#invalid-bytecodes"}},[t._v("#")]),t._v(" Invalid bytecodes")]),t._v(" "),e("ul",[e("li",[t._v("Empty jumpdest section")]),t._v(" "),e("li",[t._v("Multiple jumpdest sections")]),t._v(" "),e("li",[t._v("jumpdest section after the code section")]),t._v(" "),e("li",[t._v("jumpdest section after the data section")]),t._v(" "),e("li",[t._v("Final jumploc in the table is truncated (not a valid LEB128)")]),t._v(" "),e("li",[t._v("LEB128 encoding with extra 0s (non-minimal encoding)")]),t._v(" "),e("li",[t._v("Jumpdest location pointing to PUSH data")]),t._v(" "),e("li",[t._v("Jumpdest location out of code section bounds\n"),e("ul",[e("li",[t._v("pointing into data section")]),t._v(" "),e("li",[t._v("pointing into jumpdest section")]),t._v(" "),e("li",[t._v("pointing outside container bounds")])])]),t._v(" "),e("li",[t._v("Duplicate jumpdest locations (0 deltas in table other than 1st offset)")]),t._v(" "),e("li",[t._v("Code containing "),e("code",[t._v("JUMP")]),t._v(" but no jumpdest table")]),t._v(" "),e("li",[t._v("Code containing "),e("code",[t._v("JUMPI")]),t._v(" but no jumpdest table")]),t._v(" "),e("li",[t._v("Code containing jumpdest table but not "),e("code",[t._v("JUMP")]),t._v("/"),e("code",[t._v("JUMPI")])]),t._v(" "),e("li",[t._v("Code containing "),e("code",[t._v("JUMPDEST")])])]),t._v(" "),e("h2",{attrs:{id:"backwards-compatibility"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[t._v("#")]),t._v(" Backwards Compatibility")]),t._v(" "),e("p",[t._v("This change poses no risk to backwards compatibility, as it is introduced at the same time EIP-3540 is. The requirement of a JUMPDEST table does not cover legacy bytecode.")]),t._v(" "),e("h2",{attrs:{id:"security-considerations"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#security-considerations"}},[t._v("#")]),t._v(" Security Considerations")]),t._v(" "),e("p",[t._v("The authors are not aware of any security or DoS risks posed by this change.")]),t._v(" "),e("h2",{attrs:{id:"copyright"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[t._v("#")]),t._v(" Copyright")]),t._v(" "),e("p",[t._v("Copyright and related rights waived via "),e("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[t._v("CC0"),e("OutboundLink")],1),t._v(".")])])}),[],!1,null,null,null);s.default=n.exports}}]);