(window.webpackJsonp=window.webpackJsonp||[]).push([[247],{644:function(e,t,a){"use strict";a.r(t);var r=a(46),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"simple-summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[e._v("#")]),e._v(" Simple Summary")]),e._v(" "),a("p",[e._v("This proposal defines Baby Jubjub, an elliptic curve designed to work inside zk-SNARK circuits in Ethereum.")]),e._v(" "),a("h2",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),a("p",[e._v("Two of the main issues behind why blockchain technology is not broadly used by individuals and industry are scalability and privacy guarantees. With a set of cryptographic tools called zero-knowledge proofs (ZKP) it is possible to address both of these problems. More specifically, the most suitable protocols for blockchain are called zk-SNARKs (zero-knowledge Succinct Non-interactive ARguments of Knowledge), as they are non-interactive, have succinct proof size and sublinear verification time. These types of protocols allow proving generic computational statements that can be modelled with arithmetic circuits defined over a finite field (also called zk-SNARK circuits).")]),e._v(" "),a("p",[e._v("To verify a zk-SNARK proof, it is necessary to use an elliptic curve. In Ethereum, the curve is alt_bn128 (also referred as BN254), which has primer order "),a("code",[e._v("r")]),e._v(". With this curve, it is possible to generate and validate proofs of any "),a("code",[e._v("F_r")]),e._v("-arithmetic circuit. This EIP describes "),a("em",[e._v("Baby Jubjub")]),e._v(", an elliptic curve defined over the finite field "),a("code",[e._v("F_r")]),e._v(" which can be used inside any zk-SNARK circuit, allowing for the implementation of cryptographic primitives that make use of elliptic curves, such as the Pedersen Hash or the Edwards Digital Signature Algorithm (EdDSA).")]),e._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),a("p",[e._v("A "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Zero-knowledge_proof",target:"_blank",rel:"noopener noreferrer"}},[e._v("zero knowledge proof"),a("OutboundLink")],1),e._v(" (ZKP) is a protocol that enables one party, the prover, to convince another, the verifier, that a statement is true without revealing any information beyond the veracity of the statement. "),a("a",{attrs:{href:"https://people.csail.mit.edu/silvio/Selected%20Scientific%20Papers/Zero%20Knowledge/Noninteractive_Zero-Knowkedge.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Non-Interactive ZKPs"),a("OutboundLink")],1),e._v(" (NIZK) are a particular type of zero-knowledge proofs in which the prover can generate the proof without interaction with the verifier. NIZK protocols are very suitable for Ethereum applications, because they allow a smart contract to act as a verifier. This way, anyone can generate a proof and send it as part of a transaction to the smart contract, which can perform some action depending on whether the proof is valid or not. In this context, the most preferable NIZK are "),a("a",{attrs:{href:"https://eprint.iacr.org/2013/279.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("zk-SNARK"),a("OutboundLink")],1),e._v(" (Zero-knowledge Succinct Non Interactive ARgument of Knowledge), a set of non-interactive zero-knowledge protocols that have succinct proof size and sublinear verification time. The importance of these protocols is double: on the one hand, they help improve privacy guarantees, and on the other, they are a possible solution to scalability issues (e.g. see "),a("a",{attrs:{href:"https://github.com/barryWhiteHat/roll_up",target:"_blank",rel:"noopener noreferrer"}},[e._v("zk-Rollup"),a("OutboundLink")],1),e._v(" project).")]),e._v(" "),a("p",[e._v("Like most ZKPs, zk-SNARKs permit proving computational statements. For example, one can prove things like: the knowledge of a private key associated with a certain public key, the correct computation of a transaction, or the knowledge of the preimage of a particular hash. Importantly, one can do these things without leaking any information about the statements in question. In other words, without leaking any information about the private key, the transaction details, or the value of the preimage. More specifically, zk-SNARKs permit proving any computational statement that can be modelled with an "),a("code",[e._v("F_r")]),e._v("-arithmetic circuit, a circuit consisting of set of wires that carry values from the field "),a("code",[e._v("F_r")]),e._v(" and connect them to addition and multiplication gates "),a("code",[e._v("mod r")]),e._v(". This type of circuits are often called zk-SNARK circuits.")]),e._v(" "),a("p",[e._v("The implementation of most zk-SNARK protocols (e.g. "),a("a",{attrs:{href:"https://eprint.iacr.org/2013/279.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("[Pinnochio]"),a("OutboundLink")],1),e._v(" and "),a("a",{attrs:{href:"https://eprint.iacr.org/2016/260.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("[Groth16]"),a("OutboundLink")],1),e._v(") make use of an elliptic curve for validating a proof. In Ethereum, the curve used is alt_bn128 (also referred as BN254), which has prime order "),a("code",[e._v("r")]),e._v(". While it is possible to generate and validate proofs of "),a("code",[e._v("F_r")]),e._v("-arithmetic circuits with BN254, it is not possible to use BN254 to implement elliptic-curve cryptography within these circuits. To implement functions that require the use of elliptic curves inside a zk-SNARK circuit -- such as the "),a("a",{attrs:{href:"https://github.com/zcash/zips/blob/master/protocol/protocol.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Pedersen Hash"),a("OutboundLink")],1),e._v(" or the "),a("a",{attrs:{href:"https://tools.ietf.org/html/rfc8032",target:"_blank",rel:"noopener noreferrer"}},[e._v("Edwards Digital Signature Algorithm"),a("OutboundLink")],1),e._v(" (EdDSA) -- a new curve with coordinates in "),a("code",[e._v("F_r")]),e._v(" is needed. To this end, we propose in this EIP "),a("em",[e._v("Baby Jubjub")]),e._v(", an elliptic curve defined over "),a("code",[e._v("F_r")]),e._v(" that can be used inside any "),a("code",[e._v("F_r")]),e._v("-arithmetic circuit. In the next sections we describe in detail the characteristics of the curve, how it was generated, and which security considerations were taken.")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("    inputs                zk-SNARK (alt_bn128)             output\n            +--------------------------------------------+\n            |   +--------------------+                   |\n        ---\x3e|   | EdDSA (Baby Jubjub)|                   |\n            |   +--------------------+                   | \n        ---\x3e|                                            |---\x3e\n            |          +-----------------------------+   |\n        ---\x3e|          | Pedersen Hash (Baby Jubjub) |   |\n            |          +-----------------------------+   |\n            +--------------------------------------------+\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br")])]),a("h2",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),a("h3",{attrs:{id:"definitions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#definitions"}},[e._v("#")]),e._v(" Definitions")]),e._v(" "),a("p",[e._v("Let "),a("code",[e._v("F_r")]),e._v(" be the prime finite field with "),a("code",[e._v("r")]),e._v(" elements, where")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("r = 21888242871839275222246405745257275088548364400416034343698204186575808495617\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("Let "),a("code",[e._v("E")]),e._v(" be the twisted Edwards elliptic curve defined over "),a("code",[e._v("F_r")]),e._v(" described by equation")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ax^2 + y^2 = 1 + dx^2y^2\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("with parameters")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("a = 168700\nd = 168696\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("We call "),a("strong",[e._v("Baby Jubjub")]),e._v(" the curve "),a("code",[e._v("E(F_r)")]),e._v(", that is, the subgroup of "),a("code",[e._v("F_r")]),e._v("-rational points of "),a("code",[e._v("E")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"order"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#order"}},[e._v("#")]),e._v(" Order")]),e._v(" "),a("p",[e._v("Baby Jubjub has order")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("n = 21888242871839275222246405745257275088614511777268538073601725287587578984328\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("which factors in")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("n = h x l\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("where")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("h = 8\nl = 2736030358979909402780800718157159386076813972158567259200215660948447373041\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("The parameter "),a("code",[e._v("h")]),e._v(" is called "),a("em",[e._v("cofactor")]),e._v(" and "),a("code",[e._v("l")]),e._v(" is a prime number of 251 bits.")]),e._v(" "),a("h3",{attrs:{id:"generator-point"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#generator-point"}},[e._v("#")]),e._v(" Generator Point")]),e._v(" "),a("p",[e._v("The point "),a("code",[e._v("G = (x,y)")]),e._v(" with coordinates")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("x = 995203441582195749578291179787384436505546430278305826713579947235728471134\ny = 5472060717959818805561601436314318772137091100104008585924551046643952123905\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("generates all "),a("code",[e._v("n")]),e._v(" points of the curve.")]),e._v(" "),a("h3",{attrs:{id:"base-point"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#base-point"}},[e._v("#")]),e._v(" Base Point")]),e._v(" "),a("p",[e._v("The point "),a("code",[e._v("B = (x,y)")]),e._v(" with coordinates")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("x = 5299619240641551281634865583518297030282874472190772894086521144482721001553\ny = 16950150798460657717958625567821834550301663161624707787222815936182638968203\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("generates the subgroup of points "),a("code",[e._v("P")]),e._v(" of Baby Jubjub satisfying "),a("code",[e._v("l * P = O")]),e._v(". That is, it generates the set of points of order "),a("code",[e._v("l")]),e._v(" and origin "),a("code",[e._v("O")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"arithmetic"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#arithmetic"}},[e._v("#")]),e._v(" Arithmetic")]),e._v(" "),a("p",[e._v("Let "),a("code",[e._v("P1 = (x1, y1)")]),e._v(" and "),a("code",[e._v("P2 = (x2, y2)")]),e._v(" be two arbitrary points of Baby Jubjub. Then "),a("code",[e._v("P1 + P2 = (x3, y3)")]),e._v(" is calculated in the following way:")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("x3 = (x1*y2 + y1*x2)/(1 + d*x1*x2*y1*y2)\ny3 = (y1*y2 - a*x1*x2)/(1 - d*x1*x2*y1*y2)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("Note that both addition and doubling of points can be computed using a single formula.")]),e._v(" "),a("h2",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),a("p",[e._v("The search for Baby Jubjub was motivated by the need for an elliptic curve that allows the implementation of elliptic-curve cryptography in "),a("code",[e._v("F_r")]),e._v("-arithmetic circuits. The curve choice was based on three main factors: type of curve, generation process and security criteria. This section describes how these factors were addressed.")]),e._v(" "),a("p",[a("strong",[e._v("Form of the Curve")])]),e._v(" "),a("p",[e._v("Baby Jubjub is a "),a("strong",[e._v("twisted Edwards")]),e._v(" curve birationally equivalent to a "),a("strong",[e._v("Montgomery")]),e._v(" curve. The choice of this form of curve was based on the following facts:")]),e._v(" "),a("ol",[a("li",[e._v("The Edwards-curve Digital Signature Scheme is based on twisted Edwards curves.")]),e._v(" "),a("li",[e._v("Twisted Edwards curves have a single complete formula for addition of points, which makes the implementation of the group law inside circuits very efficient "),a("a",{attrs:{href:"https://eprint.iacr.org/2008/013.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("[Crypto08/013, Section 6]"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("li",[e._v("As a twisted Edwards curve is generally birationally equivalent to a Montgomery curve "),a("a",{attrs:{href:"https://eprint.iacr.org/2008/013.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("[Crypto08/13,Theorem 3.2]"),a("OutboundLink")],1),e._v(", the curve can be easily converted from one form to another. As addition and doubling of points in a Montgomery curve can be performed very efficiently, computations outside the circuit can be done faster using this form and sped up inside circuits by combining it with twisted Edwards form (see "),a("a",{attrs:{href:"http://hyperelliptic.org/EFD/g1p/index.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),a("OutboundLink")],1),e._v(") for more details).")])]),e._v(" "),a("p",[a("strong",[e._v("Generation of the Curve")])]),e._v(" "),a("p",[e._v("Baby Jubjub was conceived as a solution to the circuit implementation of cryptographic schemes that require elliptic curves. As with any cryptographic protocol, it is important to reduce the possibility of a backdoor being present. As a result, we designed the generation process to be "),a("strong",[e._v("transparent")]),e._v(" and "),a("strong",[e._v("deterministic")]),e._v(" -- in order to make it clear that no external considerations were taken into account, and to ensure that the process can be reproduced and followed by anyone who wishes to do so.")]),e._v(" "),a("p",[e._v("The algorithm chosen for generating Baby Jubjub is based in the criteria defined in "),a("a",{attrs:{href:"https://tools.ietf.org/html/rfc7748",target:"_blank",rel:"noopener noreferrer"}},[e._v("[RFC7748, Appendix A.1]"),a("OutboundLink")],1),e._v(" and can be found in "),a("a",{attrs:{href:"https://github.com/barryWhiteHat/baby_jubjub",target:"_blank",rel:"noopener noreferrer"}},[e._v("this github repository"),a("OutboundLink")],1),e._v(". Essentially, the algorithm takes a prime number "),a("code",[e._v("p = 1 mod 4")]),e._v(" and returns the lowest "),a("code",[e._v("A>0")]),e._v(" such that "),a("code",[e._v("A-2")]),e._v(" is a multiple of 4 and such that the set of solutions in "),a("code",[e._v("F_p")]),e._v(" of "),a("code",[e._v("y^2 = x^3 + Ax^2 + x")]),e._v(" defines a Montgomery curve with cofactor 8.")]),e._v(" "),a("p",[e._v("Baby Jubjub was generated by running the algorithm with the prime")]),e._v(" "),a("p",[a("code",[e._v("r = 21888242871839275222246405745257275088548364400416034343698204186575808495617")]),e._v(",")]),e._v(" "),a("p",[e._v("which is the order of alt_bn128, the curve used to verfiy zk-SNARK proofs in Ethereum. The output of the algorithm was "),a("code",[e._v("A=168698")]),e._v(". Afterwards, the corresponding Montgomery curve was transformed into twisted Edwards form. Using SAGE libraries for curves, the order "),a("code",[e._v("n")]),e._v(" of the curve and its factorization "),a("code",[e._v("n = 8*l")]),e._v(" was calculated.")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("Choice of generator")]),e._v(" : the generator point "),a("code",[e._v("G")]),e._v(" is the point of order "),a("code",[e._v("n")]),e._v(" with smallest positive "),a("code",[e._v("x")]),e._v("-coordinate in "),a("code",[e._v("F_r")]),e._v(".")]),e._v(" "),a("li",[a("strong",[e._v("Choice of base point")]),e._v(": the base point "),a("code",[e._v("B")]),e._v(" is chosen to be "),a("code",[e._v("B = 8*G")]),e._v(", which has order "),a("code",[e._v("l")]),e._v(".")])]),e._v(" "),a("p",[a("strong",[e._v("Security Criteria")])]),e._v(" "),a("p",[e._v("It is crucial that Baby Jubjub be safe against well-known attacks. To that end, we decided that the curve should pass "),a("a",{attrs:{href:"https://safecurves.cr.yp.to/",target:"_blank",rel:"noopener noreferrer"}},[e._v("SafeCurves"),a("OutboundLink")],1),e._v(" security tests, as they are known for gathering the best known attacks against elliptic curves. Supporting evidence that Baby Jubjub satisfies the SafeCurves criteria can be found "),a("a",{attrs:{href:"https://github.com/barryWhiteHat/baby_jubjub",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"backwards-compatibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),a("p",[e._v("Baby Jubjub is a twisted Edwards elliptic curve birational to different curves. So far, the curve has mainly been used in its original form, in Montomgery form, and in another (different representation) twisted Edwards form -- which we call the reduced twisted Edwards form.")]),e._v(" "),a("p",[e._v("Below are the three representations and the birational maps that make it possible to map points from one form of the curve to another. In all cases, the generator and base points are written in the form "),a("strong",[a("code",[e._v("(x,y)")]),e._v(".")])]),e._v(" "),a("h3",{attrs:{id:"forms-of-the-curve"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#forms-of-the-curve"}},[e._v("#")]),e._v(" Forms of the Curve")]),e._v(" "),a("p",[e._v("All generators and base points are written in the form (x,y).")]),e._v(" "),a("p",[a("strong",[e._v("Twisted Edwards Form")]),e._v(" (standard)")]),e._v(" "),a("ul",[a("li",[e._v("Equation: "),a("code",[e._v("ax^2 + y^2 = 1 + dx^2y^2")])]),e._v(" "),a("li",[e._v("Parameters: "),a("code",[e._v("a = 168700, d = 168696")])]),e._v(" "),a("li",[e._v("Generator point:"),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("(995203441582195749578291179787384436505546430278305826713579947235728471134, 5472060717959818805561601436314318772137091100104008585924551046643952123905)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])])]),e._v(" "),a("li",[e._v("Base point:"),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("(5299619240641551281634865583518297030282874472190772894086521144482721001553, 16950150798460657717958625567821834550301663161624707787222815936182638968203)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])])])]),e._v(" "),a("p",[a("strong",[e._v("Montgomery Form")])]),e._v(" "),a("ul",[a("li",[e._v("Equation: "),a("code",[e._v("By^2 = x^3 + A x^2 + x")])]),e._v(" "),a("li",[e._v("Parameters: "),a("code",[e._v("A = 168698, B = 1")])]),e._v(" "),a("li",[e._v("Generator point:"),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("(7, 4258727773875940690362607550498304598101071202821725296872974770776423442226)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])])]),e._v(" "),a("li",[e._v("Base point:"),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("(7117928050407583618111176421555214756675765419608405867398403713213306743542, 14577268218881899420966779687690205425227431577728659819975198491127179315626)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])])])]),e._v(" "),a("p",[a("strong",[e._v("Reduced Twisted Edwards Form")])]),e._v(" "),a("ul",[a("li",[e._v("Equation: "),a("code",[e._v("a' x^2 + y^2 = 1 + d' x^2y^2")])]),e._v(" "),a("li",[e._v("Parameters:"),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("a' = -1 \nd' = 12181644023421730124874158521699555681764249180949974110617291017600649128846\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])])]),e._v(" "),a("li",[e._v("Generator point:"),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("(4986949742063700372957640167352107234059678269330781000560194578601267663727, 5472060717959818805561601436314318772137091100104008585924551046643952123905)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])])]),e._v(" "),a("li",[e._v("Base point:"),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("(9671717474070082183213120605117400219616337014328744928644933853176787189663, 16950150798460657717958625567821834550301663161624707787222815936182638968203)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])])])]),e._v(" "),a("h3",{attrs:{id:"conversion-of-points"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#conversion-of-points"}},[e._v("#")]),e._v(" Conversion of Points")]),e._v(" "),a("p",[e._v("Following formulas allow to convert points from one form of the curve to another. We will denote the coordinates")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("(u, v)")]),e._v(" for points in the Montomgery form,")]),e._v(" "),a("li",[a("code",[e._v("(x, y)")]),e._v(" for points in the Twisted Edwards form and")]),e._v(" "),a("li",[a("code",[e._v("(x', y')")]),e._v(" for points in reduced Twisted Edwards form.")])]),e._v(" "),a("p",[e._v("Note that in the last conversion -- from Twisted Edwards to Reduced Twisted Edwards and back -- we also use the scaling factor "),a("code",[e._v("f")]),e._v(", where:")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("f = 6360561867910373094066688120553762416144456282423235903351243436111059670888\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("In the expressions one can also use directly "),a("code",[e._v("-f")]),e._v(", where:")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("-f = 15527681003928902128179717624703512672403908117992798440346960750464748824729\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[a("strong",[e._v("Montgomery --\x3e Twisted Edwards")])]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("(u, v) --\x3e (x, y)\n\nx = u/v\ny = (u-1)/(u+1)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[a("strong",[e._v("Twisted Edwards --\x3e Montgomery")])]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("(x, y) --\x3e (u, v)\n\nu = (1+y)/(1-y) \nv = (1+y)/((1-y)x)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[a("strong",[e._v("Montgomery --\x3e Reduced Twisted Edwards")])]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("(u, v) --\x3e (x', y')\n\nx' = u*(-f)/v \ny' = (u-1)/(u+1) \n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[a("strong",[e._v("Reduced Twisted Edwards --\x3e Montgomery")])]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("(x', y') --\x3e (u, v)\n\nu = (1+y')/(1-y')\nv = (-f)*(1+y')/((1-y')*x')\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[a("strong",[e._v("Twisted Edwards --\x3e Reduced Twisted Edwards")])]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("(x, y) --\x3e (x', y')\n\nx' = x*(-f)\ny' = y\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[a("strong",[e._v("Reduced Twisted Edwards --\x3e Twisted Edwards")])]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("(x', y') --\x3e (x, y)\n\nx = x'/(-f)\ny = y'\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("h2",{attrs:{id:"security-considerations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#security-considerations"}},[e._v("#")]),e._v(" Security Considerations")]),e._v(" "),a("p",[e._v("This section specifies the safety checks done on Baby Jubjub. The choices of security parameters are based on "),a("a",{attrs:{href:"https://safecurves.cr.yp.to",target:"_blank",rel:"noopener noreferrer"}},[e._v("SafeCurves criteria"),a("OutboundLink")],1),e._v(", and supporting evidence that Baby Jubjub satisfies the following requisites can be found "),a("a",{attrs:{href:"https://github.com/barryWhiteHat/baby_jubjub",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("p",[a("strong",[e._v("Curve Parameters")])]),e._v(" "),a("p",[e._v("Check that all parameters in the specification of the curve describe a well-defined elliptic curve over a prime finite field.")]),e._v(" "),a("ul",[a("li",[e._v("The number "),a("code",[e._v("r")]),e._v(" is prime.")]),e._v(" "),a("li",[e._v("Parameters "),a("code",[e._v("a")]),e._v(" and "),a("code",[e._v("d")]),e._v(" define an equation that corresponds to an elliptic curve.")]),e._v(" "),a("li",[e._v("The product of "),a("code",[e._v("h")]),e._v(" and "),a("code",[e._v("l")]),e._v(" results into the order of the curve and the "),a("code",[e._v("G")]),e._v(" point is a generator.")]),e._v(" "),a("li",[e._v("The number "),a("code",[e._v("l")]),e._v(" is prime and the "),a("code",[e._v("B")]),e._v(" point has order "),a("code",[e._v("l")]),e._v(".")])]),e._v(" "),a("p",[a("strong",[e._v("Elliptic Curve Discrete Logarithm Problem")])]),e._v(" "),a("p",[e._v("Check that the discrete logarithm problem remains difficult in the given curve. We checked Baby Jubjub is resistant to the following known attacks.")]),e._v(" "),a("ul",[a("li",[a("em",[e._v("Rho method")]),e._v(" "),a("a",{attrs:{href:"https://www.cambridge.org/core/books/elliptic-curves-in-cryptography/16A2B60636EFA7EBCC3D5A5D01F28546",target:"_blank",rel:"noopener noreferrer"}},[e._v("[Blake-Seroussi-Smart, Section V.1]"),a("OutboundLink")],1),e._v(": we require the cost for the rho method, which takes on average around "),a("code",[e._v("0.886*sqrt(l)")]),e._v(" additions, to be above "),a("code",[e._v("2^100")]),e._v(".")]),e._v(" "),a("li",[a("em",[e._v("Additive and multiplicative transfers")]),e._v(" "),a("a",{attrs:{href:"https://www.cambridge.org/core/books/elliptic-curves-in-cryptography/16A2B60636EFA7EBCC3D5A5D01F28546",target:"_blank",rel:"noopener noreferrer"}},[e._v("[Blake-Seroussi-Smart, Section V.2]"),a("OutboundLink")],1),e._v(": we require the embedding degree to be at least "),a("code",[e._v("(l âˆ’ 1)/100")]),e._v(".")]),e._v(" "),a("li",[a("em",[e._v("High discriminant")]),e._v(" "),a("a",{attrs:{href:"https://www.cambridge.org/core/books/elliptic-curves-in-cryptography/16A2B60636EFA7EBCC3D5A5D01F28546",target:"_blank",rel:"noopener noreferrer"}},[e._v("[Blake-Seroussi-Smart, Section IX.3]"),a("OutboundLink")],1),e._v(": we require the complex-multiplication field discriminant "),a("code",[e._v("D")]),e._v(" to be larger than "),a("code",[e._v("2^100")]),e._v(".")])]),e._v(" "),a("p",[a("strong",[e._v("Elliptic Curve Cryptography")])]),e._v(" "),a("ul",[a("li",[a("em",[e._v("Ladders")]),e._v(" "),a("a",{attrs:{href:"https://wstein.org/edu/Fall2001/124/misc/montgomery.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("[Montgomery]"),a("OutboundLink")],1),e._v(": check the curve supports the Montgomery ladder.")]),e._v(" "),a("li",[a("em",[e._v("Twists")]),e._v(" "),a("a",{attrs:{href:"https://safecurves.cr.yp.to/twist.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("[SafeCurves, twist]"),a("OutboundLink")],1),e._v(": check it is secure against the small-subgroup attack, invalid-curve attacks and twisted-attacks.")]),e._v(" "),a("li",[a("em",[e._v("Completeness")]),e._v(" "),a("a",{attrs:{href:"https://safecurves.cr.yp.to/complete.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("[SafeCurves, complete]"),a("OutboundLink")],1),e._v(": check if the curve has complete single-scalar and multiple-scalar formulas.")]),e._v(" "),a("li",[a("em",[e._v("Indistinguishability")]),e._v(" "),a("a",{attrs:{href:"https://eprint.iacr.org/2013/325",target:"_blank",rel:"noopener noreferrer"}},[e._v("[IACR2013/325]"),a("OutboundLink")],1),e._v(": check availability of maps that turn elliptic-curve points indistinguishable from uniform random strings.")])]),e._v(" "),a("h2",{attrs:{id:"test-cases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test-cases"}},[e._v("#")]),e._v(" Test Cases")]),e._v(" "),a("p",[a("strong",[e._v("Test 1 (Addition)")])]),e._v(" "),a("p",[e._v("Consider the points "),a("code",[e._v("P1 = (x1, y1)")]),e._v(" and "),a("code",[e._v("P2 = (x2, y2)")]),e._v(" with the following coordinates:")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("x1 = 17777552123799933955779906779655732241715742912184938656739573121738514868268\ny1 = 2626589144620713026669568689430873010625803728049924121243784502389097019475\n\nx2 = 16540640123574156134436876038791482806971768689494387082833631921987005038935\ny2 = 20819045374670962167435360035096875258406992893633759881276124905556507972311\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("Then their sum "),a("code",[e._v("P1+P2 = (x3, y3)")]),e._v(" is equal to:")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("x3 = 7916061937171219682591368294088513039687205273691143098332585753343424131937\ny3 = 14035240266687799601661095864649209771790948434046947201833777492504781204499\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[a("strong",[e._v("Test 2 (Doubling)")])]),e._v(" "),a("p",[e._v("Consider the points "),a("code",[e._v("P1 = (x1, y1)")]),e._v(" and "),a("code",[e._v("P2 = (x2, y2)")]),e._v(" with the following coordinates:")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("x1 = 17777552123799933955779906779655732241715742912184938656739573121738514868268,\ny1 = 2626589144620713026669568689430873010625803728049924121243784502389097019475\n\nx2 = 17777552123799933955779906779655732241715742912184938656739573121738514868268\ny2 = 2626589144620713026669568689430873010625803728049924121243784502389097019475\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("Then their sum "),a("code",[e._v("P1+P2 = (x3, y3)")]),e._v(" is equal to:")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("x3 = 6890855772600357754907169075114257697580319025794532037257385534741338397365\ny3 = 4338620300185947561074059802482547481416142213883829469920100239455078257889\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[a("strong",[e._v("Test 3 (Doubling the identity)")])]),e._v(" "),a("p",[e._v("Consider the points "),a("code",[e._v("P1 = (x1, y1)")]),e._v(" and "),a("code",[e._v("P2 = (x2, y2)")]),e._v(" with the following coordinates:")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("x1 = 0\ny1 = 1\n\nx2 = 0\ny2 = 1\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("Then their sum "),a("code",[e._v("P1+P2 = (x3, y3)")]),e._v(" results in the same point:")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("x3 = 0\ny3 = 1\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[a("strong",[e._v("Test 4 (Curve membership)")])]),e._v(" "),a("p",[e._v("Point "),a("code",[e._v("(0,1)")]),e._v(" is a point on Baby Jubjub.")]),e._v(" "),a("p",[e._v("Point "),a("code",[e._v("(1,0)")]),e._v(" is not a point on Baby Jubjub.")]),e._v(" "),a("p",[a("strong",[e._v("Test 5 (Base point choice)")])]),e._v(" "),a("p",[e._v("Check that the base point "),a("code",[e._v("B = (Bx, By)")]),e._v(" with coordinates")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Bx = 5299619240641551281634865583518297030282874472190772894086521144482721001553\nBy = 16950150798460657717958625567821834550301663161624707787222815936182638968203\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("is 8 times the generator point "),a("code",[e._v("G = (Gx, Gy)")]),e._v(", where")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Gx = 995203441582195749578291179787384436505546430278305826713579947235728471134\nGy = 5472060717959818805561601436314318772137091100104008585924551046643952123905\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("That is, check that "),a("code",[e._v("B = 8 x G")]),e._v(".")]),e._v(" "),a("p",[a("strong",[e._v("Test 6 (Base point order)")])]),e._v(" "),a("p",[e._v("Check that the base point "),a("code",[e._v("B = (Bx, By)")]),e._v(" with coordinates")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Bx = 5299619240641551281634865583518297030282874472190772894086521144482721001553\nBy = 16950150798460657717958625567821834550301663161624707787222815936182638968203\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("multiplied by "),a("code",[e._v("l")]),e._v(", where")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("l = 2736030358979909402780800718157159386076813972158567259200215660948447373041\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("results in the origin point "),a("code",[e._v("O = (0, 1)")]),e._v(". This test checks that the base point "),a("code",[e._v("B")]),e._v(" has order "),a("code",[e._v("l")]),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),a("p",[e._v("Arithmetic of Baby Jubjub and some cryptographic primitives using the curve have already been implemented in different languages. Here are a few such implementations:")]),e._v(" "),a("ul",[a("li",[e._v("Python: https://github.com/barryWhiteHat/baby_jubjub_ecc")]),e._v(" "),a("li",[e._v("JavaScript: https://github.com/iden3/circomlib/blob/master/src/babyjub.js")]),e._v(" "),a("li",[e._v("Circuit (circom): https://github.com/iden3/circomlib/blob/master/circuits/babyjub.circom")]),e._v(" "),a("li",[e._v("Rust: https://github.com/arnaucube/babyjubjub-rs")]),e._v(" "),a("li",[e._v("Solidity: https://github.com/yondonfu/sol-baby-jubjub")]),e._v(" "),a("li",[e._v("Go: https://github.com/iden3/go-iden3-crypto/tree/master/babyjub")])]),e._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),a("p",[e._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),a("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=s.exports}}]);